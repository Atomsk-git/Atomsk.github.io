<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Redis - Atomsk</title><meta description="NoSQLNoSQL &amp;#x3D; Not Only SQL  NoSQL特点   方便扩展（数据之间没有关系，很好扩展） 高性能 数据类型是多样性的 传统的 RDBMS和NoSQL对比"><meta property="og:type" content="article"><meta property="og:title" content="Redis"><meta property="og:url" content="https://atomsk.gitee.io/blog/2020/08/08/redis/"><meta property="og:site_name" content="Atomsk"><meta property="og:description" content="NoSQLNoSQL &amp;#x3D; Not Only SQL  NoSQL特点   方便扩展（数据之间没有关系，很好扩展） 高性能 数据类型是多样性的 传统的 RDBMS和NoSQL对比"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://atomsk.gitee.io/img/og_image.png"><meta property="article:published_time" content="2020-08-08T00:26:16.000Z"><meta property="article:modified_time" content="2020-08-08T09:44:13.737Z"><meta property="article:author" content="Atomsk"><meta property="article:tag" content="数据库"><meta property="article:tag" content="Redis"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://atomsk.gitee.io/blog/2020/08/08/redis/"},"headline":"Atomsk","image":["https://atomsk.gitee.io/img/og_image.png"],"datePublished":"2020-08-08T00:26:16.000Z","dateModified":"2020-08-08T09:44:13.737Z","author":{"@type":"Person","name":"Atomsk"},"description":"NoSQLNoSQL &#x3D; Not Only SQL  NoSQL特点   方便扩展（数据之间没有关系，很好扩展） 高性能 数据类型是多样性的 传统的 RDBMS和NoSQL对比"}</script><link rel="canonical" href="https://atomsk.gitee.io/blog/2020/08/08/redis/"><link rel="icon" href="/blog/img/favicon.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/blog/css/default.css"><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script></head><body class="is-3-column"><script type="text/javascript" src="/blog/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/blog/"><img class="logo-img" src="/blog/img/logo.ico" alt="Atomsk" height="28"><img class="logo-img-dark" src="/blog/img/logo.ico" alt="Atomsk" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/blog/">首页</a><a class="navbar-item" href="/blog/archives/">时间轴</a><a class="navbar-item" href="/blog/categories/">分类</a><a class="navbar-item" href="/blog/tags/">标签</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-08T00:26:16.000Z" title="2020-08-08T00:26:16.000Z">2020-08-08</time><span class="level-item"> Atomsk </span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span> / </span><a class="link-muted" href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/">NoSQL</a></span><span class="level-item">2 小时 读完 (大约 14796 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Redis</h1><div class="content"><h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL = Not Only SQL</p>
<blockquote>
<p>NoSQL特点</p>
</blockquote>
<ol>
<li>方便扩展（数据之间没有关系，很好扩展）</li>
<li>高性能</li>
<li>数据类型是多样性的</li>
<li>传统的 RDBMS和NoSQL对比</li>
</ol>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传统的 RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中 row col</span><br><span class="line">- 操作操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- .....</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Nosql</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">- 最终一致性，</span><br><span class="line">- CAP定理和BASE （异地多活） 初级架构师！（狂神理念：只要学不死，就往死里学！）</span><br><span class="line">- 高性能，高可用，高可扩</span><br><span class="line">- ....</span><br></pre></td></tr></table></figure>



<blockquote>
<p>NoSQL的四大分类</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>Examples举例</strong></th>
<th>典型应用场景</th>
<th>数据模型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>key-value</strong></td>
<td>Tyrant， Redis， Voldemort， Oracle BDB</td>
<td>内容缓存，主要用于处理大量数据的高访问负载</td>
<td>Key-Value对应的键值对，通常用hash table来实现</td>
<td>查找速度快</td>
<td>数据无结构化，通常只被当作字符串或者二进制数据</td>
</tr>
<tr>
<td><strong>列存储数据库</strong></td>
<td>Cassandra， HBase， Riak</td>
<td>分布式的文件系统</td>
<td>以列簇式存储，将同一列数据存在一起</td>
<td>查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td>功能相对局限</td>
</tr>
<tr>
<td><strong>文档型数据库</strong></td>
<td>CouchDB， MongoDb</td>
<td>Web应用</td>
<td>Key-Value对应的键值对，Value为结构化数据</td>
<td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>
<td>查询性能不高，而且缺乏统一的查询语法。</td>
</tr>
<tr>
<td><strong>图形数据库</strong></td>
<td>Neo4J， InfoGrid， Infinite Graph</td>
<td>社交网络，推荐系统等。专注于构建关系图谱</td>
<td>图结构</td>
<td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td>
<td>很多时候需要对整个图做计算才能得出需要的信息，不容易做分布式集群方案</td>
</tr>
</tbody></table>
<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><p>Redis（Remote Dictionary Server )，即远程字典服务，</p>
<p>是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C语言">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/数据库/103728">数据库</a>，并提供多种语言的API。</p>
<blockquote>
<p>Redis 能干嘛？</p>
</blockquote>
<ol>
<li><p>内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）</p>
</li>
<li><p>效率高，可以用于高速缓存</p>
</li>
<li><p>发布订阅系统</p>
</li>
<li><p>地图信息分析</p>
</li>
<li><p>计时器、计数器（浏览量！）</p>
</li>
</ol>
<blockquote>
<p>特性</p>
</blockquote>
<ol>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
</ol>
<blockquote>
<p>学习中需要用到的东西</p>
</blockquote>
<ol>
<li>狂神的公众号：狂神说</li>
<li>官网：<a href="https://redis.io/">https://redis.io/</a></li>
<li>中文网：<a href="http://www.redis.cn/">http://www.redis.cn/</a></li>
</ol>
<blockquote>
<p>基础知识</p>
</blockquote>
<p>redis默认有16个数据库，默认使用的是第0个</p>
<p><code>SELECT</code>：切换数据库，<code>DBSIZE</code>查看当前db大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Redis:0&gt;select 1</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">Redis:1&gt;dbsize</span><br><span class="line">&quot;0&quot;</span><br></pre></td></tr></table></figure>

<p><code>FLUSHDB</code>：清除当前数据库 </p>
<p><code>FLUSHALL</code>：清除全部数据库的内容</p>
<blockquote>
<p>Redis是单线程的</p>
</blockquote>
<p>明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所有就使用了单线程了！</p>
<p>Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的Memecache差！</p>
<p><strong>Redis 为什么单线程还这么快？</strong></p>
<p>1、误区1：高性能的服务器一定是多线程的？</p>
<p>2、误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</p>
<p>先去CPU&gt;内存&gt;硬盘的速度要有所了解！</p>
<p>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作<font color='red'>数据库、缓存和消息中间件</font>。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
<h2 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h2><p>官方中文文档：<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<p>基本命令：</p>
<ol>
<li><code>keys</code> pattern( 使用 * 表示查询所有的key)</li>
<li><code>del</code> key[key2 key3…] (删除键值对)</li>
<li><code>move</code> key db（移动key到指定db）</li>
<li><code>exists</code> key (不存在返回0，存在返回1)</li>
<li><code>type</code> key (返回value 的类型)</li>
</ol>
<h2 id="Strings（字符串）"><a href="#Strings（字符串）" class="headerlink" title="Strings（字符串）"></a>Strings（字符串）</h2><ol>
<li><p>介绍</p>
<ol>
<li><p>字符串类型是Redis中最为基础的数据存储类型</p>
</li>
<li><p>二进制安全，意味着一个Redis字符串能包含任意类型的数据</p>
</li>
<li><p>最多可以容纳的数据长度是512M字节。</p>
</li>
<li><p>有趣用法：</p>
<ul>
<li><p>利用INCR命令簇（<a href="http://www.redis.cn/commands/incr.html">INCR</a>, <a href="http://www.redis.cn/commands/decr.html">DECR</a>, <a href="http://www.redis.cn/commands/incrby">INCRBY</a>）来把字符串当作原子计数器使用。</p>
</li>
<li><p>利用<a href="http://www.redis.cn/commands/setrange.html">SETRANGE</a>和<a href="http://www.redis.cn/commands/getrange.html">GETRANGE</a>命令，可以把字符串当成线性数组，随机访问只要O(1)复杂度</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>set</p>
<ol>
<li><p>设置或覆盖一个值：<code>SET</code> key value [EX seconds] [PX milliseconds] [NX|XX]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- EX *seconds* – 设置键key的过期时间，单位时秒</span><br><span class="line">- PX *milliseconds* – 设置键key的过期时间，单位时毫秒</span><br><span class="line">- NX – 只有键key不存在的时候才会设置key的值</span><br><span class="line">- XX – 只有键key存在的时候才会设置key的值</span><br><span class="line">注意: 由于SET命令加上选项已经可以完全取代SETNX, SETEX, PSETEX的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置多个值：<code>mset</code> key value [key value …]</p>
</li>
<li><p>设置values到对应keys上： <code>msetnx</code> key value [key value …]，是个原子操作，要么一起成功（返回1），要么一起失败（返回0）</p>
</li>
</ol>
</li>
<li><p>查</p>
<ol>
<li>获取指定key的值：<code>get</code> key，只处理String类型的值</li>
<li>获取多个key的值：<code>mget</code> key [key …]</li>
<li>返回指定范围的value的子串:<code>getrange</code> key start end</li>
<li>获取指定字符串的长度：<code>strlen</code> key</li>
</ol>
</li>
<li><p>存值并返回原值：<code>getset</code> key value （get andthen set），如果原本不存在值，则返回null</p>
</li>
<li><p>改</p>
<ol>
<li>从指定的offset处开始，覆盖value的长度：<code>setrange</code> key offset value</li>
<li>追加值：<code>append</code> key value，如果当前key不存在，就相当于set key</li>
</ol>
</li>
</ol>
<p><strong>使用示例</strong></p>
<p>set、get、append：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx name atomsk # 创建值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;atomsk&quot;</span><br><span class="line">127.0.0.1:6379&gt; set name fanerlin # 覆盖值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;fanerlin&quot;</span><br><span class="line">127.0.0.1:6379&gt; append name 85 # 追加值</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;fanerlin85&quot;</span><br></pre></td></tr></table></figure>

<p>mset、mget、setnx、msetnx、getset：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; setnx k2 v2 # 失败，因为k2已存在</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setnx k3 v3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; msetnx k3 v3 k4 v4 # 失败，因为k3已存在</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; msetnx k4 v4 k5 v5 # 成功，可见上面的k4创建失败了</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getset k5 v5n # 返回的是修改前的值</span><br><span class="line">&quot;v5&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k5</span><br><span class="line">&quot;v5n&quot;</span><br></pre></td></tr></table></figure>


<ol start="5">
<li><code>incr</code>、<code>decr</code>和<code>incrby</code>、<code>decrby</code> （i++、i– 和 i+= 步长、 i-= 步长）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set views 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; incrby views 10</span><br><span class="line">(integer) 20</span><br><span class="line">127.0.0.1:6379&gt; decrby views 10</span><br><span class="line">(integer) 10</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>getrange</code>字符串截取和<code>setrange</code>字符串替换</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set str abcde</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange str 0 2 # 截取字符串 [0,2]</span><br><span class="line">&quot;abc&quot;</span><br><span class="line">127.0.0.1:6379&gt; setrange str 3 abc # 从指定位置开始替换字符串</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;abcabc&quot;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>对象操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name atomsk user:1:age 22</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) &quot;atomsk&quot;</span><br><span class="line">2) &quot;22&quot;</span><br><span class="line">127.0.0.1:6379&gt; set user:2 &#123;name:fanerlin,age:85&#125; # 用json字符来保存一个对象</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:2</span><br><span class="line">&quot;&#123;name:fanerlin,age:85&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>使用Redis Desktop Manager查看：</p>
<p>![image-20200804134314476](redis/Sting Object.png)</p>
<h2 id="Lists（列表）"><a href="#Lists（列表）" class="headerlink" title="Lists（列表）"></a>Lists（列表）</h2><ol>
<li>介绍<ol>
<li>List类型是按照插入顺序排序的字符串列表。(可以左右操作)</li>
<li>有序(插入顺序)，有索引，可重复</li>
<li>有趣用法：<ul>
<li>在社交网络中建立一个时间线模型，使用<a href="http://www.redis.cn/commands/lpush.html">LPUSH</a>去添加新的元素到用户时间线中，使用<a href="http://www.redis.cn/commands/lrange.html">LRANGE</a>去检索一些最近插入的条目。</li>
<li>你可以同时使用<a href="http://www.redis.cn/commands/lpush.html">LPUSH</a>和<a href="http://www.redis.cn/commands/ltrim.html">LTRIM</a>去创建一个永远不会超过指定元素数目的列表并同时记住最后的N个元素。</li>
</ul>
</li>
</ol>
</li>
<li>增<ol>
<li><code>Lpush</code> list value1[value2…]</li>
<li><code>Rpush</code> list value1[value2…]</li>
<li><code>Lpushx</code> list value，当list存在时才插入value到list表头</li>
<li><code>Rpushx</code> list value，当list存在时才插入value到list表尾</li>
</ol>
</li>
<li>查<ol>
<li>查询出指定区间元素：<code>lrange</code> list start end （闭区间），示例：<code>lrange list 0 -1</code> （查询所有）</li>
<li>通过索引获得值：<code>lindex</code> list index ， 从0开始，从左到右，右边第一个索引-1</li>
<li>查列表的长度：<code>llen</code> list </li>
</ol>
</li>
<li>删<ol>
<li><code>Lpop</code> list ，移除列表的第一个元素</li>
<li><code>Rpop</code> list ，移除列表的最后一个元素</li>
<li><code>lrem</code> list count element，移除列表指定个数的指定元素，优先移除左边元素</li>
</ol>
</li>
<li>改<ol>
<li><code>ltram</code> list start end，通过下标截取list，会改变原来的list</li>
<li><code>lset</code> list index value，修改指定索引上的值，修改不存在list或者索引越界会报错</li>
<li><code>linsert</code> key BEFORE|AFTER 位置 value，在指定位置前|后插入值</li>
<li><code>RpopLpush</code> sourceList targetList，<code>Rpop</code>出一个列表的元素，并将其<code>Lpush</code>到其他列表中！</li>
</ol>
</li>
</ol>
<p><strong>使用示例</strong></p>
<ol>
<li>Lpush、Rpush、lrange、lrem</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list one two three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; rpush list three</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 three # 移除一个three</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 # 优先移除掉了左边的three</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line">3) &quot;three&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ltram、lset</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ltrim list 1 2 # 截取保留区间[1,2]的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list -1 four # 修改最后一个值为 four</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;four&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list123 1 one # 修改不存在的list</span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lset list 5 five # 修改不存在的索引</span><br><span class="line">(error) ERR index out of range</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>linsert</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; linsert list after one two</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; linsert list before four three</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;four&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>他实际上是一个链表， left，right，before|after Node ，都可以插入值</li>
<li>如果移除了所有值，空链表，也代表不存在！</li>
<li>在两边插入或者改动值，效率最高！改动中间元素，相对来说效率会低一点~</li>
</ul>
<p>消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）！</p>
<h2 id="Sets（集合）"><a href="#Sets（集合）" class="headerlink" title="Sets（集合）"></a>Sets（集合）</h2><ol>
<li><p>介绍</p>
<ol>
<li>无序的字符串合集，可以以<strong>O(1)</strong> 的时间复杂度（无论集合中有多少元素时间复杂度都为常量）完成 添加，删除以及测试元素是否存在的操作。</li>
<li>有趣用法：<ul>
<li>用集合跟踪一个独特的事。想要知道所有访问某个博客文章的独立IP？只要每次都用SADD来处理一个页面访问。那么你可以肯定重复的IP是不会插入的。</li>
<li>Redis集合能很好的表示关系。你可以创建一个tagging系统，然后用集合来代表单个tag。接下来你可以用<a href="http://www.redis.cn/commands/sadd.html">SADD</a>命令把所有拥有tag的对象的所有ID添加进集合，这样来表示这个特定的tag。如果你想要同时有3个不同tag的所有对象的所有ID，那么你需要使用<a href="http://www.redis.cn/commands/sinter.html">SINTER</a>.</li>
</ul>
</li>
</ol>
</li>
<li><p>增</p>
<ol>
<li>增加一个或多个元素成员：<code>sadd</code> set value[value2…]，如果成员已存在则忽略</li>
</ol>
</li>
<li><p>查</p>
<ol>
<li>查所有成员：<code>smembers</code> </li>
<li>随机抽选出一个或多个成员：<code>srandmember</code> set [count]</li>
<li>判断是否是set的成员：<code>sismember</code> set value</li>
<li>查成员数量：<code>scard</code> set</li>
</ol>
</li>
<li><p>删</p>
<ol>
<li>随机删除一个或多个成员：<code>spop</code> set [count]</li>
<li>删除指定成员：<code>srem</code> set members[member1,member2…] </li>
</ol>
</li>
<li><p>改</p>
<ol>
<li>移动指定成员到目标set：<code>smove</code> sourceSet targetSet value</li>
</ol>
</li>
<li><p><strong>集合操作</strong></p>
<ol>
<li>差集：<code>Sdiff</code> key [key …]，返回一个集合与给定集合的差集的元素.</li>
<li>交集：<code>Sinter</code> key [key …]，返回指定所有的集合的成员的交集.</li>
<li>并集：<code>Sunion</code> key [key …]，返回给定的多个集合的并集中的所有成员.</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set1 a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd set2 b c d</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff set2 set1</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinter set1 set2</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; sunion set1 set2</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">4) &quot;a&quot;</span><br></pre></td></tr></table></figure>



<h2 id="Hashes（哈希）"><a href="#Hashes（哈希）" class="headerlink" title="Hashes（哈希）"></a>Hashes（哈希）</h2><ol>
<li>Redis Hashes是字符串字段和字符串值之间的映射，可以看成具有String Key和对象数据(filed value)的Map容器</li>
<li>增<ol>
<li>设置一个或多个值：<code>hset</code> key field1 value1 [field2 value2 …]，返回1是新增，0是修改</li>
<li><code>hmset</code>和<code>hset</code>用法和作用一样</li>
</ol>
</li>
<li>指定字段不存在时，设置值：<code>hsetnx</code></li>
<li>查<ol>
<li>查一个字段的值：<code>hget</code> key field</li>
<li>查多个字段的值：<code>hmget</code> key field1 [field2 …]</li>
<li>查出所有字段的名字：<code>hkeys</code> key</li>
<li>查出所有字段的值：<code>hvals</code> key</li>
<li>查所有的字段和值：<code>hgetall</code> key</li>
<li>获取hash表的字段数量：<code>hlen</code> key</li>
<li>获取指定字段的长度：<code>hstrlen</code> key field</li>
</ol>
</li>
<li>判断指定字段是否存在：<code>hexists</code> key field，存在返回1，不存在0</li>
<li>删除一个或多个字段：<code>hdel</code> key field1 [field2 …] </li>
<li>增加|减少字段的值：<code>hincrby</code>和<code>hdecrby</code> key field value</li>
</ol>
<p><strong>使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name atomsk age 22</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;atomsk&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;22&quot;</span><br><span class="line">127.0.0.1:6379&gt; hkeys user</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals user</span><br><span class="line">1) &quot;atomsk&quot;</span><br><span class="line">2) &quot;22&quot;</span><br><span class="line">127.0.0.1:6379&gt; hlen user</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; hstrlen user name</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; hexists user email</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的存储，String更加适合字符串存储！</p>
<h2 id="Sorted-sets（有序集合）"><a href="#Sorted-sets（有序集合）" class="headerlink" title="Sorted sets（有序集合）"></a>Sorted sets（有序集合）</h2><ol>
<li><p>介绍</p>
<ol>
<li>和集合的差别是，每个有序集合的成员都关联着一个评分（score），集合成员按score从低到高排序</li>
<li>一个数据(score,value) 其中score可重复,value不可重复</li>
<li>有趣用法：<ul>
<li>在一个巨型在线游戏中建立一个排行榜，每当有新的记录产生时，使用<a href="http://www.redis.cn/commands/zadd.html">ZADD</a> 来更新它。你可以用ZRANGE轻松地获取排名靠前的用户， 你也可以提供一个用户名，然后用<a href="http://www.redis.cn/commands/zrank.html">ZRANK</a>获取他在排行榜中的名次。 同时使用<a href="http://www.redis.cn/commands/zrank.html">ZRANK</a>和<a href="http://www.redis.cn/commands/zrange.html">ZRANGE</a>你可以获得与指定用户有相同分数的用户名单。 所有这些操作都非常迅速。</li>
<li>有序集合通常用来索引存储在Redis中的数据。 例如：如果你有很多的hash来表示用户，那么你可以使用一个有序集合，这个集合的年龄字段用来当作评分，用户ID当作值。用<a href="http://www.redis.cn/commands/zrangebyscore.html">ZRANGEBYSCORE</a>可以简单快速地检索到给定年龄段的所有用户。</li>
</ul>
</li>
</ol>
</li>
<li><p>通用指令</p>
<ol>
<li><p>将指定成员添加到ss里：<code>zadd</code> key [NX|XX] [CH] [INCR] score member [score member …]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XX: 仅仅更新存在的成员，不添加新成员。</span><br><span class="line">NX: 不更新存在的成员。只添加新成员。</span><br><span class="line">CH: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 changed 的意思)。更改的元素是新添加的成员，已经存在的成员更新分数。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，ZADD返回值只计算新添加成员的数量。</span><br><span class="line">INCR: 当ZADD指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作。</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回指定<strong>索引</strong>范围的元素：<code>zrange</code> key start stop[withscores]，从高到低：<code>zrevrange</code></p>
</li>
<li><p>返回成员数量：<code>zcard</code> key</p>
</li>
<li><p>移除指定成员：<code>zrem</code> key member [member …]</p>
</li>
</ol>
</li>
<li><p>*<em>score *</em>分数相关指令</p>
<ol>
<li><p>返回成员的score值：<code>zscore</code> key member</p>
</li>
<li><p>按<strong>score</strong>从低到高排序：<code>zrangebyscore</code> key min max [withscores] [limit offset count]，min和max指定socre的范围，使用limit进行分页，从高到低：<code>zrevrangebyscore</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##区间及无限</span><br><span class="line">min和max可以是-inf和+inf，这样一来，你就可以在不知道有序集的最低和最高score值的情况下，使用ZRANGEBYSCORE这类命令。</span><br><span class="line">默认情况下，区间的取值使用闭区间，你也可以通过给参数前增加 ( 符号来使用可选的开区间。</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取指定score区间的成员数量：<code>zcount</code> key min max</p>
</li>
<li><p>移除指定score区间的成员：<code>zremrangebyscore</code> key min max</p>
</li>
<li><p>删除一个或多个score最高|最低的成员：<code>zpopmax</code>|<code>zpopmin</code> key [count]</p>
</li>
</ol>
</li>
<li><p><strong>lex</strong> 相关指令（成员分数相同时才能使用）：</p>
<ol>
<li>返回指定成员区间内的成员，按成员字典正序排序：<code>zrangebylex</code> key min max [LIMIT offset count]，按倒序：<code>zrevrangebylex</code></li>
<li>获取指定成员之间的成员数量：<code>zlexcount</code> zset [member1 [member2</li>
<li>删除名称按字典由低到高排序成员之间所有成员：<code>zremrangebylex</code> key min max</li>
</ol>
</li>
<li><p><strong>rank</strong> 排名相关指令(score值最小的成员排名为0)：</p>
<ol>
<li>返回指定成员的排名，按从小到大排：<code>zrank</code> key member，从大到小排：<code>zrevrank</code></li>
<li>移除指定排名区间的成员：<code>zremrangebyrank</code> key start stop</li>
</ol>
</li>
<li><p>集合操作</p>
<ol>
<li><p>并集：<code>zunionstore</code> destination numkeys key [key …] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">把numkeys个集合的并集放到destination中</span><br><span class="line">weights，乘法因子，可选，有几个key就得有几个weight，让score在传递给聚合函数前相乘</span><br><span class="line">aggregate,SUM，保留score为所有score之和，MAX|MIN，选择保留最大或者最小score</span><br></pre></td></tr></table></figure>
</li>
<li><p>交集：<code>zinterstore</code>，用法和上面一样</p>
</li>
</ol>
</li>
</ol>
<p><strong>使用示例</strong></p>
<ol>
<li><p>通用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset 10 one 20 two 30 three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange zset 1 2 withscores # 返回索引[1,2]的成员</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;30&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcard zset</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrem zset one # 移除成员 one </span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>score相关命令</p>
</li>
<li><p>lex相关命令</p>
</li>
<li><p>rank相关命令</p>
</li>
<li><p>集合操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ZRANGE programmer 0 -1 WITHSCORES</span><br><span class="line">1) &quot;peter&quot;</span><br><span class="line">2) &quot;2000&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGE manager 0 -1 WITHSCORES</span><br><span class="line">1) &quot;bob&quot;</span><br><span class="line">2) &quot;4000&quot;</span><br><span class="line"># 公司决定加薪。。。除了程序员。。。</span><br><span class="line">redis 127.0.0.1:6379&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES</span><br><span class="line">1) &quot;peter&quot;</span><br><span class="line">2) &quot;2000&quot;</span><br><span class="line">3) &quot;bob&quot;</span><br><span class="line">4) &quot;12000&quot;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h1 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h1><h2 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h2><h2 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog 基数统计"></a>Hyperloglog 基数统计</h2><h2 id="Bitmap-位图"><a href="#Bitmap-位图" class="headerlink" title="Bitmap 位图"></a>Bitmap 位图</h2><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis 事务：事务中的所有命令都会序列化、按顺序地执行。</p>
<p>Redis事务不保证原子性，原因：</p>
<ul>
<li>有命令入队失败（如出现<strong>编译型异常</strong>）时，事务中所有命令都不会被执行，这种情况保证原子性，但是</li>
<li>命令存在语法问题（如 incr 一个非数值型字符串）但入队成功，在执行失败时，不会影响到其他命令的正常执行</li>
</ul>
<p>事务执行流程：</p>
<ul>
<li><p>使用<code>muliti</code>开启事务</p>
</li>
<li><p>执行命令，让命令进入事务队列</p>
</li>
<li><p>使用<code>exec</code>执行事务</p>
<p>或者</p>
</li>
<li><p>使用<code>discard</code>清空事务队列， 并放弃执行事务。</p>
</li>
</ul>
<blockquote>
<p>WATCH</p>
</blockquote>
<p>被 <a href="http://www.redis.cn/commands/watch.html">WATCH</a> 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 <a href="http://www.redis.cn/commands/exec.html">EXEC</a> 执行之前被修改了， 那么整个事务都会被取消， <a href="http://www.redis.cn/commands/exec.html">EXEC</a> 返回<a href="http://www.redis.cn/topics/protocol.html#nil-reply">nil-reply</a>来表示事务已经失败。</p>
<p>使用<code>watch</code>命令实现乐观锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money # 监视key money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi # 如果数据期间没有发生变动，事务就正常执行成功！</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby pay 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20</span><br></pre></td></tr></table></figure>

<p>取消对键的监控：</p>
<ol>
<li>使用<code>unwatch</code>手动取消对所有键的监视</li>
<li>执行<code>exec</code>后， 不管事务是否成功执行， 对所有键的监视都会被取消。</li>
<li>执行<code>discard</code>后</li>
</ol>
<blockquote>
<p>脚本和事务</p>
</blockquote>
<p>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.73<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>常用API</p>
</blockquote>
<p>方法名和命令一样</p>
<p><a href="https://gitee.com/Atomsk/practice/tree/redis/redis-01-jedis">https://gitee.com/Atomsk/practice/tree/redis/redis-01-jedis</a></p>
<blockquote>
<p>事务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">txTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    System.out.println(jedis.ping());</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    jsonObject.put(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">    jsonObject.put(<span class="string">"name"</span>,<span class="string">"kuangshen"</span>);</span><br><span class="line">    String result = jsonObject.toJSONString();</span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    Transaction multi = jedis.multi();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        multi.set(<span class="string">"user1"</span>,result);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span> ; <span class="comment">// 代码抛出异常事务，执行失败！</span></span><br><span class="line">        multi.set(<span class="string">"user2"</span>,result);</span><br><span class="line">        multi.exec(); <span class="comment">// 执行事务！</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        multi.discard(); <span class="comment">// 放弃事务</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(jedis.get(<span class="string">"user1"</span>));</span><br><span class="line">        System.out.println(jedis.get(<span class="string">"user2"</span>));</span><br><span class="line">        jedis.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h1><p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！</p>
<p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p>
<p><strong>jedis</strong> : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式</p>
<p><strong>lettuce</strong> : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式<br>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = &#123;<span class="string">"redisTemplate"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    <span class="comment">//默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span></span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">    connection.flushDb();</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">"k1"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用原生的RedisTemplate会有编码问题，因为使用的都是默认的序列化方式</p>
<p>所以自己配置一个RedisTemplate：</p>
<blockquote>
<p>自定义RedisTemplate</p>
</blockquote>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@author 狂神说</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   然后把自动注入改成以下即可</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate</span><br></pre></td></tr></table></figure>



<blockquote>
<p>RedisUtil</p>
</blockquote>
<p>企业开发中，一般不使用原生RedisTemplate的API，会将自己自定义的Template再进行封装，使用Redis工具类：</p>
<p><a href="https://gitee.com/Atomsk/practice/blob/redis/redis-02-springboot/src/main/java/com/atomsk/utils/RedisUtils.java">https://gitee.com/Atomsk/practice/blob/redis/redis-02-springboot/src/main/java/com/atomsk/utils/RedisUtils.java</a></p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bind 127.0.0.1   # 绑定的ip，使用docker时不配置</span></span><br><span class="line">protected-mode yes <span class="comment"># 保护模式</span></span><br><span class="line">port 6379  <span class="comment"># 端口设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个并发量高的环境中，你需要指定一个比较大的backlog值来避免慢连接的情况</span></span><br><span class="line"><span class="comment"># 注意，linux内核会默认 使用/proc/sys/net/core/somaxconn 的值来削减 backlog的实际值，</span></span><br><span class="line"><span class="comment"># 因此你需要确保提升 somaxconn 和 tcp_max_syn_backlog 这两个值来确保此处的backlog生效</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭掉空闲N秒的连接（0则是不处理空闲连接）</span></span><br><span class="line">timeout 0</span><br></pre></td></tr></table></figure>



<h2 id="General"><a href="#General" class="headerlink" title="General"></a>General</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">daemonize no  <span class="comment"># 以守护进程的方式运行，如果在使用docker管理redis时开启，会导致redis启动失败，因为docker的redis默认没有pidfile文件</span></span><br><span class="line">pidfile /var/run/redis_6379.pid  <span class="comment"># 如果以后台的方式运行，我们就需要指定一个 pid 文件</span></span><br><span class="line"></span><br><span class="line">databases 16  <span class="comment"># 数据库的数量，默认是 16 个数据库</span></span><br><span class="line">always-show-logo no  <span class="comment"># 是否总是显示LOGO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志的记录级别的</span></span><br><span class="line"><span class="comment"># debug (尽可能多的日志信息，用于开发和测试之中)</span></span><br><span class="line"><span class="comment"># verbose (少但是有用的信息, 没有debug级别那么混乱)</span></span><br><span class="line"><span class="comment"># notice (适量的信息，用于生产环境)</span></span><br><span class="line"><span class="comment"># warning (只有非常重要和关键的信息会被记录)</span></span><br><span class="line">loglevel notice</span><br><span class="line">logfile <span class="string">""</span> <span class="comment"># 日志的文件位置名</span></span><br></pre></td></tr></table></figure>



<h2 id="持久化相关"><a href="#持久化相关" class="headerlink" title="持久化相关"></a>持久化相关</h2><p>redis 是内存数据库，如果没有持久化，那么数据断电即失</p>
<p><a href="https://atomskgit.github.io/blog/2020/08/08/redis/#RDB配置">RDB配置</a></p>
<p><a href="https://atomskgit.github.io/blog/2020/08/08/redis/#AOF配置">AOF配置</a></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><a href="https://atomskgit.github.io/blog/2020/08/08/redis/#Replication配置">Replication配置</a></p>
<h2 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全 Security"></a>安全 Security</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get requirepass  <span class="comment"># 获取redis的密码</span></span><br><span class="line">1) <span class="string">"requirepass"</span></span><br><span class="line">2) <span class="string">""</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass <span class="string">"123456"</span>  <span class="comment"># 设置redis的密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass  <span class="comment"># 发现所有的命令都没有权限了</span></span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456  <span class="comment"># 使用密码进行登录！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">"requirepass"</span></span><br><span class="line">2) <span class="string">"123456"</span></span><br></pre></td></tr></table></figure>



<h2 id="限制-Clients"><a href="#限制-Clients" class="headerlink" title="限制 Clients"></a>限制 Clients</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000  <span class="comment"># 设置能连接上redis的最大客户端的数量</span></span><br><span class="line">maxmemory &lt;bytes&gt;  <span class="comment"># redis 配置最大的内存容量</span></span><br><span class="line">maxmemory-policy noeviction  <span class="comment"># 内存容量超过maxmemory后的处理策略 </span></span><br><span class="line">    volatile-lru：利用LRU算法移除设置过过期时间的key。</span><br><span class="line">    volatile-random：随机移除设置过过期时间的key。</span><br><span class="line">    volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）</span><br><span class="line">    allkeys-lru：利用LRU算法移除任何key。</span><br><span class="line">    allkeys-random：随机移除任何key。</span><br><span class="line">    noeviction：不移除任何key，只是返回一个写错误。</span><br></pre></td></tr></table></figure>



<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p>
<h2 id="RDB（Redis-Database"><a href="#RDB（Redis-Database" class="headerlink" title="RDB（Redis Database)"></a>RDB（Redis Database)</h2><blockquote>
<p>什么是RDB</p>
</blockquote>
<p>默认的redis数据库，主从复制中的从机，即数据库备份</p>
<img src="/blog/2020/08/08/redis/RDB.png" class="" title="image-20200805153201269">

<p>在指定的时间间隔内将内存中的数据集<strong>快照</strong>写入磁盘，恢复时将快照文件直接读到内存里。</p>
<ul>
<li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。</li>
<li>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，<strong>RDB方式</strong>要比<strong>AOF方式</strong>更加的高效。</li>
<li>默认的持久化方式就是RDB，一般情况下不需要修改</li>
</ul>
<p><font color='red'>db保存的文件是 <strong>dump.rdb</strong></font> ，可以在配置文件中进行配置，有时候在生产环境我们会将这个文件进行备份！</p>
<h3 id="RDB配置"><a href="#RDB配置" class="headerlink" title="RDB配置"></a>RDB配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当存在最少一个key 变更时，900秒(15分钟)后保存到硬盘</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes  <span class="comment"># 持久化如果出错，是否还需要继续工作！</span></span><br><span class="line">dbfilename dump.rdb <span class="comment"># rdb文件名</span></span><br><span class="line">rdbcompression yes <span class="comment"># 是否压缩 rdb 文件，需要消耗一些cpu资源！</span></span><br><span class="line">rdbchecksum yes <span class="comment"># 保存rdb文件的时候，进行错误的检查校验！</span></span><br><span class="line">dir ./  <span class="comment"># rdb 文件保存的目录！</span></span><br></pre></td></tr></table></figure>

<p><strong>触发机制</strong></p>
<ol>
<li>save的规则满足的情况下，会自动触发rdb规则</li>
<li>执行 flushall 命令，也会触发我们的rdb规则！</li>
<li>退出redis，也会产生 rdb 文件！</li>
</ol>
<p>机制触发后会自动生成一个 dump.rdb文件</p>
<p><strong>恢复方式</strong></p>
<ol>
<li><p>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</p>
</li>
<li><p>查看需要存在的位置</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) <span class="string">"dir"</span></span><br><span class="line">2) <span class="string">"/usr/local/bin"</span>  <span class="comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>优点和缺点</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ol>
<li>适合大规模的数据恢复！</li>
<li>对数据的完整性要求不高！</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，最后一次的修改数据就没有的了！</li>
<li>fork进程的时候，会占用一定的内容空间！   </li>
</ol>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！</p>
<img src="/blog/2020/08/08/redis/AOF.png" class="" title="AOF">

<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p><font color='red'>Aof保存的是 appendonly.aof 文件</font></p>
<h3 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h3><p>AOF默认是不开启的，把 appendonly 改为yes就开启了 aof，重启 redis 就可以生效了，可以和RDB方式一起使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly no   <span class="comment"># 默认不开启</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span>  <span class="comment"># 持久化的文件的名字</span></span><br></pre></td></tr></table></figure>

<p><strong>持久化策略</strong></p>
<p>appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能差但数据完整性比较好</p>
<p><font color='green'>appendfsync everysec</font> ，默认选项，异步操作，每秒记录，如果一秒钟内宕机，会有数据丢失</p>
<p>appendfsync no 将缓存回写的策略交给系统，linux 默认是30秒将缓冲区的数据回写硬盘的</p>
<p><strong>重写规则</strong></p>
<p>AOF采用文件追加的方式持久化数据，所以文件会越来越大，为了避免这种情况发生，增加了重写机制</p>
<p>当AOF文件的大小超过了配置所设置的阙值时，Redis就会启动AOF文件压缩，只保留可以恢复数据的最小指令集</p>
<p>触发机制：Redis会记录上次重写时的AOF文件大小，默认配置时当目前aof文件大小超过上一次重写的aof文件大小的百分之 <strong>100</strong> ，且文件大于 <strong>64M</strong> 时触发</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间</span></span><br><span class="line"><span class="comment"># 为了减少延迟可以改为yes，为了更安全的持久化保持默认的no</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当截断的aof文件被导入的时候，会自动发布一个log给客户端然后读取</span></span><br><span class="line"><span class="comment"># 关闭后需要手动修复aof文件</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"><span class="comment"># 在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，</span></span><br><span class="line"><span class="comment"># 系统会每32MB执行一次fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>

<p><strong>AOF文件损坏修复方法</strong></p>
<p>如果 aof 文件有错位，redis 会启动失败，可以使用 <code>redis-check-aof --fix aoffile</code> 进行修复</p>
<blockquote>
<p>和RDB相比</p>
</blockquote>
<p><strong>优点</strong>：通常情况下AOF文件保存的数据比RDB文件保存的数据要完整</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</li>
<li>Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化！</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p>
</li>
<li><p>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</p>
</li>
<li><p><font color='red'>如果只做缓存，只希望数据在服务器运行的时候存在，可以不使用任何持久化</font></p>
</li>
<li><p>同时开启两种持久化方式</p>
<p>在这种情况下，当redis重启的时候会<strong>优先载入AOF文件</strong>来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p>
<p>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</p>
</li>
<li><p>性能建议</p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留<code>save 900 1</code>这条规则</li>
<li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>
</li>
</ol>
<h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、</p>
<p>微博、关注系统！</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>订阅/发布消息图：</p>
<p>第一个：消息发送者， 第二个：频道 第三个：消息订阅者！</p>
<img src="/blog/2020/08/08/redis/redis-message.png" class="" title="image-20200806161541147">

<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和client1 之间的关系：</p>
<img src="/blog/2020/08/08/redis/subscribe.png" class="" title="image-20200806161626330">

<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<img src="/blog/2020/08/08/redis/publish.png" class="" title="image-20200806161701375">



<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。</p>
<img src="/blog/2020/08/08/redis/command.png" class="" title="image-20200806161847610">

<blockquote>
<p>测试</p>
</blockquote>
<p>订阅端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe atomsk</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"atomsk"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"message"</span> <span class="comment"># 消息</span></span><br><span class="line">2) <span class="string">"atomsk"</span>  <span class="comment"># 频道名字</span></span><br><span class="line">3) <span class="string">"ground controll to major tom"</span> <span class="comment">#具体信息</span></span><br></pre></td></tr></table></figure>

<p>发送端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish atomsk <span class="string">"ground controll to major tom"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>



<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。</p>
<p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p>
<p>微信公众号：</p>
<p>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p>
<p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>
<p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<p><strong>使用场景</strong>：</p>
<ol>
<li>实时消息系统！</li>
<li>事实聊天！（频道当做聊天室，将信息回显给所有人即可！）</li>
<li>订阅，关注系统都是可以的！</li>
</ol>
<p>稍微复杂的场景我们就会使用 消息中间件 MQ </p>
<h1 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；</p>
<p><font color='red'>数据的复制是单向的，只能由主节点到从节点</font>。Master以写为主，Slave 以读为主。</p>
<p>*<em>默认情况下，每台Redis服务器都是主节点 *</em></p>
<p>一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<blockquote>
<p>主从复制的作用</p>
</blockquote>
<ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ol>
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p>
<ol>
<li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有</li>
</ol>
<p>内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过 <strong>20G</strong>。</p>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”<strong>多读少写</strong>“。</p>
<p>对于这种场景，我们可以使如下这种架构：</p>
<img src="/blog/2020/08/08/redis/master-slave.png" class="" title="image-20200806162541519">

<p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ </p>
<p>另外，slave服务器也可以有自己的slave服务器，这样的服务器称为sub-slave,而这些sub-slave通过主从复制最终数据也能与master保持一致，如下图所示：</p>
<img src="/blog/2020/08/08/redis/sub-slave.png" class="" title="img">

<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p>
<h2 id="Replication配置"><a href="#Replication配置" class="headerlink" title="Replication配置"></a>Replication配置</h2><p>默认的replication配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指导 slave 通过指定ip和端口号的 master 来获取DB数据</span></span><br><span class="line"><span class="comment">#replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="comment"># 当主服务器开启了密码保护时使用</span></span><br><span class="line"><span class="comment">#masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果从服务器失去了和主服务器之间的连接，或者当复制仍然处于处理状态的时候</span></span><br><span class="line"><span class="comment"># 1）如果设置为 yes(默认值)，从机将会持续回复来自客户端的请求，可能会回复已经过期的数据，或者返回空的数据，当从服务器第一次异步请求数据时。</span></span><br><span class="line"><span class="comment"># 2）如果被设置为 no ，从服务器就会返回"SYNC with master in progress" 这个错误，来应答所有命令除了 INFO 和 SLAVEOF</span></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置当前reids是从机时是否只读，默认为yes</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-load disabled</span><br><span class="line"></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"><span class="comment"># 主机宕机后，将高优先级的从机选举为主机</span></span><br><span class="line">replica-priority 100</span><br></pre></td></tr></table></figure>



<p>只需修改从机的以下配置：主库的ip和端口号，日志和rdb文件的名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt; </span><br><span class="line">masterauth &lt;master-password&gt; <span class="comment"># 如果master要求验证</span></span><br><span class="line">logfile <span class="string">"redis.log"</span> </span><br><span class="line">dbfilename <span class="string">"dump.rdb"</span></span><br></pre></td></tr></table></figure>



<p>修改完成后使用主机测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication <span class="comment"># 查看当前库的信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2 <span class="comment"># 从机数量和从机的具体信息</span></span><br><span class="line">slave0:ip=129.204.240.134,port=6379,state=online,offset=3784,lag=0</span><br><span class="line">slave1:ip=129.204.240.134,port=6379,state=online,offset=3784,lag=0</span><br><span class="line">···</span><br></pre></td></tr></table></figure>



<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><h3 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a>复制方式</h3><p>Redis主从复制分为以下三种方式：</p>
<ol>
<li><strong>增量复制</strong>：正常连接时，master会发生数据命令流给salve，将自身数据的改变复制到slave</li>
<li><strong>部分复制</strong>：当连接断开后，slave在重连时会尝试重新获取断开后未同步的数据</li>
<li><strong>全量复制</strong>：如果无法部分同步，则会请求进行全量复制，master将自己的rdb文件发送给slave，并记录同步期间的其他写入，再发送给slave，以达到完全同步的目的</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>master会记录一个<code>replicationId</code>的伪随机字符串，用于标识当前的数据集版本，还会记录一个当数据集的偏移量<code>offset</code>，不管master是否有slave服务器，replication Id和offset会一直记录并成对存在，我们可以通过 info replication查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">master_replid:c524efe4dd8c213633ed47febb86cf088df05c4d</span><br><span class="line">master_repl_offset:3784</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>当master与slave正常连接时，slave使用fsyn命令向master发送自己记录的旧master的replication id和offset，而master会计算与slave之间的数据偏移量，并将缓冲区中的偏移数量同步到slave，此时master和slave的数据一致。</p>
<p>而如果slave引用的replication太旧了，master与slave之间的数据差异太大，则master与slave之间会使用<strong>全量复制</strong>的进行数据同步。</p>
<h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><p><strong>故障转移</strong></p>
<p>如果主机宕机了，会根据<code>replic-priority</code>的值将优先级高的从机选举为主机——<strong>哨兵模式</strong></p>
<p>或者，（不推荐）我们可以使用  <code>SLAVEOF no one</code>把从机设置成主机，再使用命令将其他节点手动连接到最新的这个主节点，如果后面默认的主机恢复了，那就重启服务，恢复到配置文件的主从配置。</p>
<p><strong>主从复制中的key过期问题</strong></p>
<p>slave服务器没有权限处理过期的key，这样的话，对于在master上过期的key，在slave服务器就可能被读取，所以master会累积过期的key，积累一定的量之后，发送del命令到slave，删除slave上的key。</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。</p>
<p>哨兵模式能够后台监控主机是否故障，如果故障了根据投票数<strong>自动</strong>将从库转换为主库。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p>
<img src="/blog/2020/08/08/redis/sentinel-single.png" class="" title="image-20200808090047278">

<p>这里的哨兵有两个作用</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<img src="/blog/2020/08/08/redis/sentinel-multi.png" class="" title="image-20200808090211249">

<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<p><strong>测试示例</strong></p>
<ol>
<li><p>配置哨兵配置文件 sentinel.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 进行投票时所需 认为主机已宕机的 哨兵数量</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<p>1表示只要有一个哨兵认为主机宕机了，就进行投票选举</p>
</li>
<li><p>可能用到的docker命令</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis -v /home/atomsk/redis/redis.conf:/etc/redis/redis.conf -v /home/atomsk/redis/data:/data redis redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -d -p 6380:6379 --name redis<span class="_">-s</span>-01 -v /home/atomsk/redis/redis<span class="_">-s</span>-01.conf:/etc/redis/redis.conf -v /home/atomsk/redis/data:/data redis redis-server /etc/redis/redis.conf</span><br><span class="line">docker run -d -p 6381:6379 --name redis<span class="_">-s</span>-02 -v /home/atomsk/redis/redis<span class="_">-s</span>-02.conf:/etc/redis/redis.conf -v /home/atomsk/redis/data:/data redis redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -d -p 6382:6379 --name redis<span class="_">-s</span>-03 -v /home/atomsk/redis/redis<span class="_">-s</span>-03.conf:/etc/redis/redis.conf -v /home/atomsk/redis/data:/data -v /home/atomsk/redis/sentinel.conf:/etc/redis/sentinel.conf redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>



<p>优点：</p>
<ol>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</li>
</ol>
<p>缺点：</p>
<ol>
<li>Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</li>
</ol>
<h3 id="sentinel-conf详解"><a href="#sentinel-conf详解" class="headerlink" title="sentinel.conf详解"></a>sentinel.conf详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供</span></span><br><span class="line">密码</span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那</span></span><br><span class="line">里同步数据时。</span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。 </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，</span></span><br><span class="line">slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知</span></span><br><span class="line">相关人员。</span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），</span></span><br><span class="line">将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信</span><br><span class="line">息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配</span><br><span class="line">置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无</span><br><span class="line">法正常启动成功。</span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># shell编程</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已</span></span><br><span class="line">经发生改变的信息。</span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通</span></span><br><span class="line">信的</span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="comment"># 一般都是由运维来配</span></span><br><span class="line">置！</span><br></pre></td></tr></table></figure>



<h1 id="缓存穿透和雪崩"><a href="#缓存穿透和雪崩" class="headerlink" title="缓存穿透和雪崩"></a>缓存穿透和雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>（查不到）</p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p>
<img src="/blog/2020/08/08/redis/bulon.png" class="" title="image-20200808172550225">



<p><strong>缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>
<img src="/blog/2020/08/08/redis/emptyObject.png" class="" title="image-20200808172648060">



<p>但是这种方法会存在两个问题：</p>
<ol>
<li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li>
<li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>（量太大，缓存过期！）</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p>
<p><strong>加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大</p>
<img src="/blog/2020/08/08/redis/lock.png" class="" title="image-20200808172855932">



<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<img src="/blog/2020/08/08/redis/cache-snowslide.png" class="" title="image-20200808172945871">

<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>redis高可用</strong></p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</p>
<p><strong>限流降级</strong>（在SpringCloud讲解过！）</p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="link-muted mr-2" rel="tag" href="/blog/tags/Redis/">Redis</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/blog/2020/08/02/mybatis-plus/"><span class="level-item">MyBatis-Plus</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/blog/img/avatar.jpg" alt="Atomsk"></figure><p class="title is-size-4 is-block line-height-inherit">Atomsk</p><p class="is-size-6 is-block">Atomsk@126.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/blog/archives"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/blog/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/blog/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/AtomskGit" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/blog/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/blog/tags/AOP/"><span class="tag">AOP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Docker/"><span class="tag">Docker</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/HTTP/"><span class="tag">HTTP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/MyBatis/"><span class="tag">MyBatis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/MySQL/"><span class="tag">MySQL</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Oauth2/"><span class="tag">Oauth2</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Redis/"><span class="tag">Redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Spirng/"><span class="tag">Spirng</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Spring-Security/"><span class="tag">Spring Security</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/SpringBoot/"><span class="tag">SpringBoot</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/SpringMVC/"><span class="tag">SpringMVC</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Swagger2/"><span class="tag">Swagger2</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Vue/"><span class="tag">Vue</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/mybatis-plus/"><span class="tag">mybatis-plus</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">5</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/blog/categories/MyBatis/"><span class="level-start"><span class="level-item">MyBatis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/categories/SpringBoot/"><span class="level-start"><span class="level-item">SpringBoot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/blog/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"><span class="level-start"><span class="level-item">框架</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/blog/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/"><span class="level-start"><span class="level-item">NoSQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">创建型模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">结构型模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/blog/categories/%E8%BF%90%E7%BB%B4/"><span class="level-start"><span class="level-item">运维</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/blog/categories/%E9%85%8D%E7%BD%AE/"><span class="level-start"><span class="level-item">配置</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://gitee.com/Atomsk" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">码云</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://space.bilibili.com/95256449" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">狂神说</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/blog/"><img class="logo-img" src="/blog/img/logo.ico" alt="Atomsk" height="28"><img class="logo-img-dark" src="/blog/img/logo.ico" alt="Atomsk" height="28"></a><p class="size-small"><span>&copy; 2020 Atomsk</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/AtomskGit"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://atomsk.gitee.io/blog',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/blog/js/back_to_top.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="/blog/js/main.js" defer></script><script src="/blog/js/imaegoo/universe.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/blog/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>