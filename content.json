{"pages":[],"posts":[{"title":"DBCP2配置参数详解、","text":"常用链接配置 参数 描述 username 传递给JDBC驱动的用于建立连接的用户名 password 传递给JDBC驱动的用于建立连接的密码 url 传递给JDBC驱动的用于建立连接的URL driverClassName 使用的JDBC驱动的完整有效的java 类名 connectionProperties 当建立新连接时被发送给JDBC驱动的连接参数，格式必须是 [propertyName=property;]。 注意：参数user/password将被明确传递，所以不需要包括在这里。 数据源连接数量配置 参数 默认值 描述 initialSize 0 初始化连接:连接池启动时创建的初始化连接数量,1.2版本后支持 maxActive 8 最大活动连接:连接池在同一时间能够分配的最大活动连接的数量, 如果设置为非正数则表示不限制 maxIdle 8 最大空闲连接:连接池中容许保持空闲状态的最大连接数量,超过的空闲连接将被释放,如果设置为负数表示不限制 minIdle 0 最小空闲连接:连接池中容许保持空闲状态的最小连接数量,低于这个数量将创建新的连接,如果设置为0则不创建 maxWait 无限 最大等待时间:当没有可用连接时,连接池等待连接被归还的最大时间(以毫秒计数),超过时间则抛出异常,如果设置为-1表示无限等待 事务属性配置 参数 默认值 描述 defaultAutoCommit true 连接池创建的连接的默认的auto-commit状态 defaultReadOnly driver default 连接池创建的连接的默认的read-only状态. 如果没有设置则setReadOnly方法将不会被调用.(某些驱动不支持只读模式,比如:Informix) defaultTransactionIsolation driver default 连接池创建的连接的默认的TransactionIsolation状态. 下面列表当中的某一个: (参考javadoc) NONE、READ_COMMITTED、READ_UNCOMMITTED、REPEATABLE_READ、SERIALIZABLE defaultCatalog 连接池创建的连接的默认的catalog 数据源连接健康状况检查 参数 默认值 描述 validationQuery SQL查询,用来验证从连接池取出的连接,在将连接返回给调用者之前.如果指定,则查询必须是一个SQL SELECT并且必须返回至少一行记录 testOnBorrow true 指明是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个. 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 testOnReturn false 指明是否在归还到池中前进行检验. 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 testWhileIdle false 指明连接是否被空闲连接回收器(如果有)进行检验.如果检测失败,则连接将被从池中去除. 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 timeBetweenEvictionRunsMillis -1 在空闲连接回收器线程运行期间休眠的时间值,以毫秒为单位.如果设置为非正数,则不运行空闲连接回收器线程 numTestsPerEvictionRun 3 在每次空闲连接回收器线程(如果有)运行时检查的连接数量 minEvictableIdleTimeMillis 10006030 连接在池中保持空闲而不被空闲连接回收器线程(如果有)回收的最小时间值，单位毫秒 缓存语句 参数 默认值 描述 poolPreparedStatements false 开启池的prepared statement 池功能 maxOpenPreparedStatements 不限制 statement池能够同时分配的打开的statements的最大数量, 如果设置为0表示不限制 连接泄露回收 参数 默认值 描述 removeAbandoned false 标记是否删除泄露的连接,如果他们超过了removeAbandonedTimout的限制.如果设置为true, 连接被认为是被泄露并且可以被删除,如果空闲时间超过removeAbandonedTimeout. 设置为true可以为写法糟糕的没有关闭连接的程序修复数据库连接. removeAbandonedTimeout 300 泄露的连接可以被删除的超时值, 单位秒 logAbandoned false 标记当Statement或连接被泄露时是否打印程序的stack traces日志。被泄露的Statements和连接的日志添加在每个连接打开或者生成新的Statement,因为需要生成stack trace。","link":"/blog/2020/05/20/DBCP2/"},{"title":"SpringBoot整合Swagger2","text":"第一步：加入相关依赖1234567891011121314&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 第二步：创建Swagger2配置1234567891011121314151617181920@Configuration@EnableSwagger2public class Swagger2Config { @Bean Docket docket(){ return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage(\"com.atomsk.swagger2.controller\")) .paths(PathSelectors.any()) .build().apiInfo(new ApiInfoBuilder() .description(\"接口文档的描述信息\") .title(\"xxx项目接口文档\") .contact(new Contact(\"atomsk\", \"https://atomskgit.github.io/blog/\", \"atomsk@126.com\")) .version(\"v1.0\") .license(\"Apache2.0\") .build()); }} 配置完成后就可以开启项目在http://localhost:8080/swagger-ui.html里看到效果了。 第三步：给模块和接口加上注释模块相关注释123456789@ApiModel(value = \"用户实体类\",description = \"用于登录网站\")public class User { @ApiModelProperty(value = \"用户id\") private Integer id; @ApiModelProperty(value = \"用户名\") private String username; @ApiModelProperty(value = \"用户密码\") private String password; } 效果如图: 接口相关注释12345678910111213141516171819202122@Api(tags = \"用户管理相关接口\")//@Api 注解可以用来标记当前 Controller 的功能。@RestController@RequestMapping(\"/user\")public class UserController { @ApiOperation(value = \"更新用户\", notes = \"根据用户id更新用户名\") @ApiImplicitParams({ @ApiImplicitParam(name = \"id\", value = \"用户id\", required = true), @ApiImplicitParam(name = \"username\", value = \"用户名\", required = true, defaultValue = \"atomsk\") }) @ApiResponses({ @ApiResponse(code = 200, message = \"更新成功\"), @ApiResponse(code = 500, message = \"更新失败\") }) @PutMapping(\"/user\") public User updateUsernameById(String username, Integer id) { User user = new User(); user.setId(id); user.setUsername(username); return user; }} 效果如图： 注意如果配置了Spring Security，记得做以下配置防止Swagger2文件被拦截 1234567@Overridepublic void configure(WebSecurity web) throws Exception { web.ignoring() .antMatchers(\"/swagger-ui.html\") .antMatchers(\"/v2/**\") .antMatchers(\"/swagger-resources/**\");}","link":"/blog/2020/05/27/SpringBoot-Swagger2/"},{"title":"OAuth2授权码模式Demo","text":"案例架构 项目 端口 备注 auth-server 8080 授权服务器 resource-server 8081 资源服务器 client-app 8082 第三方应用 授权服务器创建SpringBoot应用并加入三个依赖： web spring cloud security spirng cloud OAuth2 1.对Spring Security做一些基本配置： 123456789101112131415161718192021222324@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"atomsk\") .password(new BCryptPasswordEncoder().encode(\"123\")) .roles(\"admin\") .and() .withUser(\"guest\") .password(new BCryptPasswordEncoder().encode(\"123\")) .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable().formLogin(); }} 2.用Redis存储token 12345678910@Configurationpublic class AccessTokenConfig { @Autowired RedisConnectionFactory redisConnectionFactory; @Bean TokenStore tokenStore(){ return new RedisTokenStore(redisConnectionFactory); }} 3.配置授权服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Configuration@EnableAuthorizationServer//开启授权服务器的自动化配置public class AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Autowired TokenStore tokenStore; @Autowired ClientDetailsService clientDetailsService; @Bean AuthorizationCodeServices authorizationCodeServices(){ /* 授权码和令牌有什么区别？授权码是用来获取令牌的，使用一次就失效，令牌则是用来获取资源的 */ return new InMemoryAuthorizationCodeServices();//将授权码存储到内存中 } @Bean AuthorizationServerTokenServices tokenServices() { DefaultTokenServices services = new DefaultTokenServices(); services.setClientDetailsService(clientDetailsService); services.setSupportRefreshToken(true);//是否支持刷新 services.setTokenStore(tokenStore);//指定token的存储方式 services.setAccessTokenValiditySeconds(60 * 60 * 2);//access_token的有效期 services.setRefreshTokenValiditySeconds(60 * 60 * 24 * 3);//refresh_token的有效期 return services; } @Override//配置token的安全约束 public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.checkTokenAccess(\"permitAll()\")//设置token的校验端点为可以直接访问 .allowFormAuthenticationForClients();//支持client_id以及client_secret作登录认证 } @Override//配置客户端的信息用于校验发来请求的客户端 public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory()//为了简单示范直接将客户端信息存储在内存里 .withClient(\"atomsk\")//客户端id .secret(new BCryptPasswordEncoder().encode(\"321\")) .resourceIds(\"res1\") .authorizedGrantTypes(\"authorization_code\",\"refresh_token\") .scopes(\"all\") .redirectUris(\"http://localhost:8082/index.html\"); } @Override//配置token的访问端点和token服务 public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authorizationCodeServices(authorizationCodeServices()) .tokenServices(tokenServices()); }} 资源服务器tip：小项目授权服务器和资源服务器可以放在一起。 和创建授权服务器一样，创建SpringBoot应用并加入三个依赖： web spring cloud security spirng cloud OAuth2 1.加入如下配置： 12345678910111213141516171819202122232425@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Bean//如果资源服务器和授权服务器是放在一起的，就不需要配置 RemoteTokenServices RemoteTokenServices tokenServices(){ RemoteTokenServices services=new RemoteTokenServices(); services.setCheckTokenEndpointUrl(\"http://localhost:8080/oauth/check_token\");//校验地址 services.setClientId(\"atomsk\"); services.setClientSecret(\"321\"); return services; } @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(\"res1\").tokenServices(tokenServices()); } @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasAnyRole(\"admin\") .anyRequest().authenticated(); }} 2.添加两个配置接口 1234567891011@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello\"; } @GetMapping(\"/admin/hello\") public String admin() { return \"admin\"; }} 第三方应用第三方应用就是一个普通的 Spring Boot 工程，创建时加入 Thymeleaf 依赖和 Web 依赖即可 1.在templates创建一个index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Tittle&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello,Oauth2 &lt;a href=\"http://localhost:8080/oauth/authorize?client_id=atomsk&amp;response_type=code\"&gt;第三方登录&lt;/a&gt;&lt;!-- &amp;scope=all&amp;redirect_uri=http://localhost:8082/index.html 在这不加也没影响--&gt;&lt;h1 th:text=\"${msg}\"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 超链接里的参数： client_id 客户端 ID，根据我们在授权服务器中的实际配置填写。 response_type 表示响应类型，这里是 code 表示响应一个授权码。 2.定一个Controller 1234567891011121314151617181920212223242526@Controllerpublic class HelloController { @Autowired RestTemplate restTemplate; @GetMapping(\"/index.html\") public String hello(String code, Model model) { if (code != null) { MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;(); map.add(\"code\", code); map.add(\"client_id\", \"atomsk\"); map.add(\"client_secret\", \"321\"); map.add(\"redirect_uri\", \"http://localhost:8082/index.html\"); map.add(\"grant_type\", \"authorization_code\"); Map&lt;String,String&gt; resp = restTemplate.postForObject(\"http://localhost:8080/oauth/token\", map, Map.class); String access_token = resp.get(\"access_token\"); System.out.println(access_token); HttpHeaders headers = new HttpHeaders(); headers.add(\"Authorization\", \"Bearer \" + access_token); HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(headers); ResponseEntity&lt;String&gt; entity = restTemplate.exchange(\"http://localhost:8081/admin/hello\", HttpMethod.GET, httpEntity, String.class); model.addAttribute(\"msg\", entity.getBody()); } return \"index\"; }} 如果 code 不为 null，也就是如果是通过授权服务器重定向到这个地址来的，那么我们做如下两个操作： 根据拿到的 code，去请求 http://localhost:8080/oauth/token 地址去获取 Token，返回的数据结构如下： 1234567{ \"access_token\": \"e7f223c4-7543-43c0-b5a6-5011743b5af4\", \"token_type\": \"bearer\", \"refresh_token\": \"aafc167b-a112-456e-bbd8-58cb56d915dd\", \"expires_in\": 7199, \"scope\": \"all\"} 接下来，根据我们拿到的 access_token，去请求资源服务器，注意 access_token 通过请求头传递，最后将资源服务器返回的数据放到 model 中 本博文完全参照江南一点雨的Oauth2的授权码模式案例写成，感兴趣的点击下面链接访问原文： http://www.javaboy.org/2020/0414/oauth2_authorization_code.html","link":"/blog/2020/05/26/SpringSecurity-OAuth2-Demo/"},{"title":"Docker进阶","text":"笔记整理来源 B站UP主遇见狂神说 Docker容器数据卷 在Docker容器的实际使用中，经常会遇到容器的数据持久化，容器之间的数据共享等问题，通常我们有两种解决方案： 数据卷（Data Volumes）：就是将容器内数据直接映射到本地主机环境的指定文件目录之中，可以理解为容器挂载一个虚拟数据卷然后 映射到一个主机目录中 数据卷容器（Data Volume Containers）：用专门的容器来挂载数据卷，其他容器通过挂载这个父容器来实现数据共享，这个专门挂载数据卷的容器就是数据卷容器，简单的总结就是有一个容器来专门管理数据的持久化和容器之间数据共享。 使用数据卷 方式一：直接使用命令挂载 -v 指定路径进行挂载 12#指定路径挂载 -v 宿主机路径:容器内路径 docker run --name vhr-data -e MYSQL_ROOT_PASSWORD=123456 -v /home/atomsk/mysql/db:/var/lib/mysql -d -p 3306:3306 mysql 匿名挂载和具名挂载 1234567891011# 匿名挂载 -v 容器内路径$ docker run -d -P --name nginx01 -v /etc/nginx nginx$ docker volume ls # 查看所有的volume的情况DRIVER VOLUME NAMElocal 33ae588fae6d34f511a769948f0d3d123c9d45c442ac7728cb85599c2657e50d # 具名挂载 -v 卷名:容器内路径$ docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx$ docker volume ls DRIVER VOLUME NAMElocal juming-nginx 也可以通过docker volume inspect 卷名查看卷的情况 注意：所有的Docker容器内的卷，在没有指定目录的情况下都是在/var/lib/docker/volumes/xxxx/_data路径下的 拓展：容器对宿主机文件的操作权限 1234567# 通过 -v 容器内路径： ro rw 改变读写权限ro #readonly 只读rw #readwrite 可读可写$ docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx$ docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！ 方式二：通过Dockerfile添加 注意：出于可移植可分享的的考虑，用以上 -v /宿主机绝对路径目录 : /容器内目录 的这种方式不能够直接在DockerFile中直接实现，因为宿主机目录是依赖于特定的宿主机的，并不能保证所有的宿主机都存在这样特定的目录 假设编写的DockerFile如下 1234567FROM 镜像名VOLUME [\"/容器内路径\"]CMD echo \"success build\"CMD /bin/bash 指令VOLUME [&quot;/生成的目录路径&quot;]就相当于docker run -it -v /容器内路径，即匿名挂载 使用数据卷容器1234$ docker run -it - -name parentContainer 镜像名$ docker run -it - -name sonContainer1 --volumes -from parentContainer 镜像名$ docker run -it - -name sonContainer2 --volumes -from parentContainer 镜像名 官网上有一句话描述的是，容器之间配置信息的传递，数据卷的生命周期会一致持续到没有容器使用它为止，换言之，只要有一个容器仍在使用该数据卷，该数据卷一直都可以进行数据共享。 通俗地来说，如果此时我们把父容器关闭掉，两个字容器之间依旧可以进行数据共享，而且通过继承子容器生成的新容器，一样可以与子容器进行数据共享。这就是docker容器间的数据传递共享。 DockerfileDockerfile 就是用来构建docker镜像的构建文件，是一个命令参数脚本。 构建步骤 编写一个Dockerfile文件 docker build -f Dockerfile名 -t 命名空间/镜像名:[tag] 构建出一个镜像 docker run 运行镜像（测试） docker push 发布镜像（DockerHub 、阿里云仓库) Dockerfile的编写基础知识： 每个保留关键字都是必须是大写字母 从上到下顺序执行，#表示注释 每一个指令都会创建一个新的镜像层 Dockerfile指令： 123456789101112FROM # 基础镜像，一切从这里开始构建MAINTAINER # 镜像是谁写的， 姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 格式举例：ADD tomcat.tar.gz /usr/local/，会自动解压WORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 保留端口配置CMD # 指定这个容器启动的时候默认运行的命令，当指定其他命令时会被替换。ls -a 指定-l =》 -l 报错ENTRYPOINT # 指定这个容器启动的时候默认运行的命令，可以在其基础上追加命令 ls -a，追加-l =》 ls -alONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。COPY # 类似ADD，直接将文件拷贝到镜像中ENV # 构建的时候设置环境变量！ ✅可以通过docker history 镜像id查看镜像的构建过程 实战：Tomcat镜像构建 准备镜像文件 准备tomcat 和 jdk到当前目录，编写好README 编写Dokerfile 12345678910111213FROM centos #MAINTAINER Atomsk&lt;Atomsk@126.com&gt;COPY README /usr/local/README #复制文件ADD jdk-8u231-linux-x64.tar.gz /usr/local/ #复制解压ADD apache-tomcat-9.0.35.tar.gz /usr/local/ #复制解压RUN yum -y install vimENV MYPATH /usr/local #设置环境变量WORKDIR $MYPATH #设置工作目录ENV JAVA_HOME /usr/local/jdk1.8.0_231 #设置环境变量ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.35 #设置环境变量ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib #设置环境变量 分隔符是：EXPOSE 8080 #设置暴露的端口CMD /usr/local/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.35/logs/catalina.out # 设置默认命令 构建镜像 12# 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件$ docker build -t mytomcat:0.1 . run镜像 1$ docker run -d -p 8080:8080 --name tomcat01 -v /home/atomsk/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test -v /home/atomsk/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs mytomcat:0.1 访问测试 发布项目(由于做了卷挂载，我们直接在本地编写项目就可以发布了！) 发布镜像发布到Dockerhub： 注册，地址 https://hub.docker.com/ 登录 12$ docker login -u 用户名#回车然后输入密码 提交 push镜像 12345# push不上去的解决方法# 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了$ docker build -t atomsk/mytomcat:0.1 .# 第二种 使用docker tag #然后再次push$ docker tag 容器id atomsk/mytomcat:1.0 #然后再次push 发布到阿里云镜像服务器： ​ 详见官网：https://cr.console.aliyun.com/repository/ 小结","link":"/blog/2020/06/28/Docker-advanced/"},{"title":"Docker基础","text":"笔记整理来源 B站UP主遇见狂神说 Docker基本概念Docker是一个使用容器开发、部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。 容器化越来越受欢迎，是因为容器有以下特点： 灵活性：即使是最复杂的应用程序也可以被容器化 轻量级：容器利用并共享主机内核 可互换的：你可以实时部署更新和升级 可移植性：你可以在本地构建、部署到云，并在任何地方运行 可伸缩：你可以增加并自动分发容器副本 可叠加：你可以垂直地、动态地叠加服务 Docker的基本组成 镜像（image)：一个镜像是一个可执行包，它包含运行应用程序所需的所有内容，包括代码、运行时环境、库、环境变量、配置文件。 容器(container)：容器是镜像的运行时实例。可以把一个容器理解成一个简易的 Linux系统。 仓库(repository)：仓库就是存放镜像的地方，Docker Hub是国外的，所以要下载镜像前要配置阿里云镜像加速器。 容器和虚拟机对比 Docker安装帮助文档：https://docs.docker.com/engine/install/ 12345678910111213141516171819202122#1.卸载旧版本$ yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine#2.Install the yum-utils package (which provides the yum-config-manager utility) and set up the stable repository.$ yum install -y yum-utils$ yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #此处用阿里云的仓库#更新yum软件包索引$ yum makecache fast#3.安装docker相关的 docker-ce 社区版 而ee是企业版$ yum install docker-ce docker-ce-cli containerd.io#4. 使用docker version查看是否按照成功$ docker version#5. 测试$ docker run hello-world 安装完成后配置阿里云镜像加速器 Docker常用命令帮助文档：https://docs.docker.com/reference/ 镜像命令使用docker image查看所有镜像相关命令 123docker images #查看所有本地主机上的镜像docker pull IMAGE[:TAG] #下载镜像docker rmi IMAGE #删除镜像 容器命令使用docker containter查看所有容器相关明命令 123docker ps #列出所有运行中的容器docker run 镜像id #新建容器并启动docker rm 容器id #删除指定容器 常用的镜像创建示例 12345678910111213mysql：docker run --name vhr-data -e MYSQL_ROOT_PASSWORD=123456 -v /home/atomsk/mysql/db:/var/lib/mysql -d -p 3306:3306 mysqlredis：docker run --name vhr-redis -d -p 6379:6379 redisrabbitmq：docker run --name vhr-rabbitmq -d -p 5672:5672 -p 15672:15672 rabbitmqnginx：docker run --name vhr-nginx -v /home/atomsk/vhr/vuehr:/usr/share/nginx/html -v /home/atomsk/vhr/nginx/nginx.conf:/etc/nginx/nginx.conf -d -p 8085:80 nginx或者docker run --name vhr-nginx -v /home/atomsk/vhr/vuehr:/usr/share/nginx/html -v /home/atomsk/vhr/nginx/default.conf:/etc/nginx/conf.d/default.conf -d -p 8085:80 nginx 启动和停止容器的操作 1234docker start 容器id #启动容器docker restart 容器id #重启容器docker stop 容器id #停止当前正在运行的容器docker kill 容器id #强制停止当前容器 其他常用命令123docker logs 容器id #查看日志docker inspect 镜像id/容器id #查看镜像/容器的元数据docker exec -it 容器id /bin/bash #进入容器 命令图解 Docker镜像详解镜像是什么镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时环境、库、环境变量和配置文件。 如何得到镜像： 从远程仓库下载 通过DockerFile自制一个镜像 镜像加载原理 UnionFS（联合文件系统） UnionFS是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 Docker镜像加载原理 Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFS。 boots(boot file system）主要包含 bootloader和 Kernel。 bootloader主要是引导加 kernel，Linux刚启动时会加载bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。 rootfs（root file system)，在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host（宿主机）的kernel，自己只需要提供rootfs就行了，由此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。 对分层的理解 思考：为什么Docker镜像要采用这种分层的结构呢？ 最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像；同时内存中也只需要加载一份base镜像，就可以为所有的容器服务了，而且镜像的每一层都可以被共享。 可以通过 docker inspect 镜像id 命令查看镜像元数据，看到镜像的具体分层信息 12345678910111213...\"RootFS\": { \"Type\": \"layers\", \"Layers\": [ \"sha256:c2adabaecedbda0af72b153c6499a0555f3a769d52370469d8f6bd6328af9b13\", \"sha256:744315296a49be711c312dfa1b3a80516116f78c437367ff0bc678da1123e990\", \"sha256:379ef5d5cb402a5538413d7285b21aa58a560882d15f1f553f7868dc4b66afa8\", \"sha256:d00fd460effb7b066760f97447c071492d471c5176d05b8af1751806a1f905f8\", \"sha256:4d0c196331523cfed7bf5bafd616ecb3855256838d850b6f3d5fba911f6c4123\", \"sha256:98b4a6242af2536383425ba2d6de033a510e049d9ca07ff501b95052da76e894\" ] },... Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统 Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。 分层特点 当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 容器层的细节说明镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。 文件操作 说明 添加文件 在容器中创建文件时，新文件被添加到容器层中。 读取文件 在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。 修改文件 在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。 删除文件 在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。（比如增加一个对应的Whiteout文件） 只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。 通过commit指令生成镜像12345678# 1、启动一个默认的tomcat$ docker run -d -p 8080:8080 tomcat# 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！$ docker exec -it 容器id# 3、拷贝文件进去# 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。# docker commit -m=\"描述信息\" -a=\"作者\" 容器id 目标镜像名:[TAG]$ docker commit -a=\"atomsk\" -m=\"add webapps app\" 容器id mytomcat:1.0 如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。","link":"/blog/2020/06/26/Docker-base/"},{"title":"MySQL高级","text":"笔记整理来源 黑马程序员MySQL教程 索引索引概述定义：索引是帮助MySQL高效获取数据的数据结构（有序）。 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。 索引的优劣势优势： 提高数据检索的效率，降低数据库的IO成本。 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。 劣势： 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件，每次更新了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。 索引结构索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。 索引 InnoDB引擎 MyISAM引擎 Memory引擎 BTREE索引 支持 支持 支持 HASH 索引 不支持 不支持 支持 Full-text 5.6版本之后支持 支持 不支持 我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。 BTREE结构BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下： 树中每个节点最多包含m个孩子。 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。 若根节点不是叶子节点，则至少有两个孩子。 所有的叶子节点都在同一层。 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1 以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。 插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。 演变过程如下： 1). 插入前4个字母 C N G A 2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点 3). 插入E，K，Q不需要分裂 4). 插入M，中间元素M字母向上分裂到父节点G 5). 插入F，W，L，T不需要分裂 6). 插入Z，中间元素T向上分裂到父节点中 7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂 8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂 到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。 B+TREE 结构B+Tree为BTree的变种，B+Tree与BTree的区别为： 1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。 2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。 3). 所有的非叶子节点都可以看作是key的索引部分。 由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。 MySQL中的B+TreeMySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。 MySQL中的 B+Tree 索引结构示意图: 索引分类 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引 唯一索引 ：索引列的值必须唯一，但允许有空值 复合索引 ：即一个索引包含多个列 索引语法创建索引、删除索引、查看索引语法： 12345678910CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type]ON tbl_name(index_col_name,...)index_col_name : column_name[(length)][ASC | DESC]#删除索引DROP INDEX index_name ON tbl_name;#查看索引,可选参数：\\GSHOW INDEX FROM table_name\\G; ALTER命令1234567891011121314151). alter table tb_name add primary key(column_list); 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL 2). alter table tb_name add unique index_name(column_list); 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次） 3). alter table tb_name add index index_name(column_list); 添加普通索引， 索引值可以出现多次。 4). alter table tb_name add fulltext index_name(column_list); 该语句指定了索引为FULLTEXT， 用于全文索引 设计原则索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。 12345678创建复合索引: CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ; 视图视图概述​ 视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 视图相对于普通的表的优势主要包括以下几项。 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 视图使用创建视图： 1234567CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 修改视图： 12345678910111213ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION]选项 : WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。 LOCAL ： 只要满足本视图的条件就可以更新。 CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值. 删除视图： 1DROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADE] 查看视图： 从 MySQL 5.1 版本开始，使用SHOW TABLES命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令，SHOW TABLE STATUS命令同理 如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW命令进行查看 ： 存储过程存储过程和函数概述​ 存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 ​ 存储过程和函数的区别在于函数必须有返回值，而存储过程没有。 存储过程使用创建： 1234CREATE PROCEDURE procedure_name ([proc_parameter[,...]])BEGIN -- SQL语句END ; 调用： 1CALL procedure_name() ; 删除： 1DROP PROCEDURE [IF EXISTS] sp_name ; 查看： 12345678-- 查询db_name数据库中的所有的存储过程select name from mysql.proc where db='db_name';-- 查询存储过程的状态信息show procedure status;-- 查询某个存储过程的定义show create procedure test.pro_test01 \\G; 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 变量 DECLARE 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 1DECLARE var_name[,...] type [DEFAULT value] SET 直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： 1SET var_name = expr [, var_name = expr] ... 示例 : 123456789101112DELIMITER $CREATE PROCEDURE pro_test1()BEGIN DECLARE NAME VARCHAR(20);#声明一个varchar型的变量name SET NAME = 'MYSQL'; #也可以使用select ... into进行赋值操作 SELECT 'MYSQL' INTO NAME; SELECT NAME ;END$DELIMITER ; 条件判断IF 语法结构 : 1234567if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; CASE 语法结构 : 123456789101112131415161718192021方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE;方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 参数传递语法格式 : 1234567create procedure procedure_name([in/out/inout] 参数名 参数类型)...IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认OUT: 该参数作为输出，也就是该参数可以作为返回值INOUT: 既可以作为输入参数，也可以作为输出参数 示例: 12345678910create procedure pro_test5(in height int , out description varchar(100))begin if height &gt;= 180 then set description='身材高挑'; elseif height &gt;= 170 and height &lt; 180 then set description='标准身材'; else set description='一般身材'; end if;end$ 调用: 123call pro_test5(168, @description)$select @description$ 小知识 @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 @@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 while循环语法结构: 12345while search_condition do statement_list end while; repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 语法结构 : 1234567REPEAT statement_list UNTIL search_conditionEND REPEAT; loop和leaveLOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下： 12345[begin_label:] LOOP statement_listEND LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 LEAVE 用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： 1234567891011121314151617CREATE PROCEDURE pro_test(in n int)BEGIN declare total int default 0; abc: LOOP IF n &lt;= 0 then leave ins; END IF; set total = total + n; set n = n - 1; END LOOP abc; select total;END 游标/光标（略）存储函数语法结构: 12345CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ...END; 案例 : 定义一个存储过程, 请求满足条件的总记录数 ; 123456789create function count_city(countryId int)returns intbegin declare cnum int ; select count(*) into cnum from city where country_id = countryId; return cnum;end 调用: 12select count_city(1);select count_city(12); 触发器介绍触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 创建触发器语法结构 : 12345678910111213create trigger trigger_name before/after insert/update/deleteon tbl_name [ for each row ] -- 行级触发器begin trigger_stmt ;end; 使用示例 需求：通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除； 首先创建一张日志表 : 12345678create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment '操作类型, insert/update/delete', operate_time datetime not null comment '操作时间', operate_id int(11) not null comment '操作表的ID', operate_params varchar(500) comment '操作参数', primary key(`id`))engine=innodb default charset=utf8; 创建 insert 型触发器，完成插入数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_insert_triggerafter insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'insert',now(),new.id,concat('插入后(id:',new.id,', name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $DELIMITER ; 创建 update 型触发器，完成更新数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_update_triggerafter update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'update',now(),new.id,concat('修改前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,') , 修改后(id',new.id, 'name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $DELIMITER ; 创建delete 行的触发器 , 完成删除数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_delete_triggerafter delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'delete',now(),old.id,concat('删除前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,')')); end $DELIMITER ; 测试： 123456insert into emp(id,name,age,salary) values(null, '光明左使',30,3500);insert into emp(id,name,age,salary) values(null, '光明右使',33,3200);update emp set age = 39 where id = 3;delete from emp where id = 5; 删除触发器语法结构 : 1drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 语法结构 ： 1show triggers ;","link":"/blog/2020/07/02/MySQL-advanced/"},{"title":"MySQL高级——索引使用和SQL优化","text":"Mysql的体系结构概览 整个MySQL Server由以下组成 Connection Pool : 连接池组件 Management Services &amp; Utilities : 管理服务和工具组件 SQL Interface : SQL接口组件 Parser : 查询分析器组件 Optimizer : 优化器组件 Caches &amp; Buffers : 缓冲池组件 Pluggable Storage Engines : 存储引擎 File System : 文件系统 1） 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 2） 服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。 3） 引擎层 存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。 4）存储层 数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。 存储引擎存储引擎概述​ 存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。 ​ Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。 ​ MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。 可以通过指定show engines ， 来查询当前数据库支持的存储引擎 创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。 查看Mysql数据库默认的存储引擎 ， 指令 ： 1show variables like '%storage_engine%' ； 各种存储引擎特性下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： 特点 InnoDB MyISAM MEMORY MERGE NDB 存储限制 64TB 有 有 没有 有 事务安全 支持 锁机制 行锁(适合高并发) 表锁 表锁 表锁 行锁 B树索引 支持 支持 支持 支持 支持 哈希索引 支持 全文索引 支持(5.6版本之后) 支持 集群索引 支持 数据索引 支持 支持 支持 索引缓存 支持 支持 支持 支持 支持 数据可压缩 支持 空间使用 高 低 N/A 低 低 内存使用 高 低 中等 低 高 批量插入速度 低 高 高 高 高 支持外键 支持 下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。 InnoDB​ InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。 InnoDB存储引擎不同于其他存储引擎的特点 ： 1. 事务控制 2. 外键约束 ​ MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。 ​ 下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。 1234567891011121314151617181920create table country_innodb( country_id int NOT NULL AUTO_INCREMENT, country_name varchar(100) NOT NULL, primary key(country_id))ENGINE=InnoDB DEFAULT CHARSET=utf8;create table city_innodb( city_id int NOT NULL AUTO_INCREMENT, city_name varchar(50) NOT NULL, country_id int NOT NULL, primary key(city_id), key idx_fk_country_id(country_id), CONSTRAINT `fk_city_country` FOREIGN KEY(country_id) REFERENCES country_innodb(country_id) ON DELETE RESTRICT ON UPDATE CASCADE)ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into country_innodb values(null,'China'),(null,'America'),(null,'Japan');insert into city_innodb values(null,'Xian',1),(null,'NewYork',2),(null,'BeiJing',1); 在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。 RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新； CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录； SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。 针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。 测试： 删除country_id为1 的country数据： 更新主表country表的字段 country_id : 更新后， 子表的数据信息为 ： 3. 存储方式 InnoDB 存储表和索引有以下两种方式 ： ①. 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。 ②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。 MyISAM​ MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： 1. 不支持事务 2. 文件存储方式 每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： .frm (存储表定义)； .MYD(MYData , 存储数据)； .MYI(MYIndex , 存储索引)； MEMORY​ Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。 MERGE​ MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。 ​ 对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。 ​ 可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。 存储引擎的选择 InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。 MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。 MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。 优化SQL的步骤查看SQL执行频率MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。 参数，session ：当前连接的统计结果，global ：自数据库上次启动至今的统计结果。如果不写，默认使用参数是“session”。 下面的命令显示了当前 session 中所有统计参数的值： 1show status like 'Com_______'; 1show status like 'Innodb_rows_%'; Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。 参数 含义 Com_select 执行 select 操作的次数，一次查询只累加 1。 Com_insert 执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。 Com_update 执行 UPDATE 操作的次数。 Com_delete 执行 DELETE 操作的次数。 Innodb_rows_read select 查询返回的行数。 Innodb_rows_inserted 执行 INSERT 操作插入的行数。 Innodb_rows_updated 执行 UPDATE 操作更新的行数。 Innodb_rows_deleted 执行 DELETE 操作删除的行数。 Connections 试图连接 MySQL 服务器的次数。 Uptime 服务器工作时间。 Slow_queries 慢查询的次数。 Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计。 Innodb_*** : 这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。 定位低效率执行SQL可以通过以下两种方式定位执行效率较低的 SQL 语句。 慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。 show processlist : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。 字段 含义 id 用户登录mysql时，系统分配的”connection_id”，可以使用函数connection_id()查看 user 显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句 host 显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户 db 显示这个进程目前连接的是哪个数据库 command 显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等 time 显示这个状态持续的时间，单位是秒 state 显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成 info 显示这个sql语句，是判断问题语句的一个重要依据 explain分析执行计划通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表的连接方式以及连接的顺序。 查询SQL语句的执行计划 ： 1explain select * from tb_item where id = 1; 字段 含义 id select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。 select_type 表示 SELECT 的连接类型 table 输出结果集的表 type 表示表的访问类型 possible_keys 表示查询时，可能使用的索引 key 实际使用的索引，如果为NULL，则没有使用索引。 key_len 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下,长度越短越好 。 rows 扫描行的数量 extra 执行情况的说明和描述 explain 之 idid 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： id 相同表示加载表的顺序是从上到下。 id 不同id值越大，优先级越高，越先被执行。 id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。 explain 之 select_type 表示 SELECT 的类型，常见的取值，如下表所示： select_type 含义 SIMPLE 简单的select查询，查询中不包含子查询或者UNION PRIMARY 查询中若包含任何复杂的子查询，最外层查询标记为该标识 SUBQUERY 在SELECT 或 WHERE 列表中包含了子查询 DERIVED 在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中 UNION 若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED UNION RESULT 从UNION表获取结果的SELECT explain 之 typetype 显示的是访问类型，是较为重要的一个指标，可取值为： type 含义 NULL MySQL不访问任何表，索引，直接返回结果 system 表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现 const 表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常量。const将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较 eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描 ref 非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行 range 只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。 index index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。 all 将遍历全表以找到匹配的行 结果值从最好到最坏以此是： 1234NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALLsystem &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。 explain 之 extra其他的额外的执行计划信息，在该列展示 。 extra 含义 using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低 using temporary 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低 using index 表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。 using where 在查找使用索引的情况下，需要回表去查询所需的数据 using index condition 查找使用了索引，但是需要回表查询数据 using index ; using where 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 show profile分析SQLMysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。 通过 have_profiling 参数，能够看到当前MySQL是否支持profile： 默认profiling是关闭的，可以通过set语句在Session级别开启profiling： 1set profiling=1; //开启profiling 开关； 通过profile，我们能够更清楚地了解SQL执行的过程。 首先，我们可以执行一系列的操作，如下图所示： 123456789show databases;use db01;show tables;select * from tb_item where id &lt; 5;select count(*) from tb_item; 执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时： 通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间： TIP ：Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。 在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间 ： 字段 含义 Status sql 语句执行的状态 Duration sql 执行过程中每一个步骤的耗时 CPU_user 当前用户占有的cpu CPU_system 系统占有的cpu trace分析优化器执行计划MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。 1）打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。 12SET optimizer_trace=\"enabled=on\",end_markers_in_json=on;set optimizer_trace_max_mem_size=1000000; 2）执行SQL语句 3）检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ： 1select * from information_schema.optimizer_trace\\G; 索引的使用索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。 避免索引失效 全值匹配 ，对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。 最左前缀法则 如果索引了多列，遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列，否则只有左边匹配上的列的索引生效 范围查询右边的列，不参与索引使用 。 根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。 不要在索引列上进行运算操作，否则索引将失效。 字符串不加单引号，会造成索引失效。 原因：在查询时，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。 尽量使用覆盖索引，避免select *，如果查询列超出索引列，也会降低性能。 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。 以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。 解决方案 ： 通过覆盖索引来解决 如果MySQL评估使用索引比全表更慢，则不使用索引。 比如：is NULL 、is NOT NULL 有时索引会失效，当NULL的数据占大多数时，查询is NULL不使用索引 in 走索引， not in 索引失效。 单列索引和复合索引。 尽量使用复合索引，而少使用单列索引 。 创建复合索引 123456create index idx_name_sta_address on tb_seller(name, status, address);就相当于创建了三个索引 ： name name + status name + status + address 创建单列索引如下，使用时数据库只会选择一个最优的索引（辨识度最高索引），并不会使用全部索引 。 123create index idx_seller_name on tb_seller(name);create index idx_seller_status on tb_seller(status);create index idx_seller_address on tb_seller(address); 查看索引使用情况123show status like 'Handler_read%'; show global status like 'Handler_read%'; 字段 含义 Handler_read_first 索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好） Handler_read_key 如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好） Handler_read_next 按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加 Handler_read_prev 按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC Handler_read_rnd 根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救 Handler_read_rnd_next 在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引 SQL优化大批量插入数据当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。 对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率： 1） 主键顺序插入 因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。 2） 关闭唯一性校验 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。 3） 手动提交事务 如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。 优化insert语句当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。 如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。 示例， 原始方式为： 123insert into tb_test values(1,'Tom');insert into tb_test values(2,'Cat');insert into tb_test values(3,'Jerry'); 优化后的方案为 ： 1insert into tb_test values(1,'Tom'),(2,'Cat')，(3,'Jerry'); 在事务中进行数据插入。 数据按主键顺序有序插入。 优化order by语句两种排序方式 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。 优化思路： 了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和order by 使用相同的索引，并且order By 的顺序和索引顺序相同， 并且order by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。 Filesort 的优化通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法： 1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。 2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。 MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。 可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。 优化group by 语句由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。 如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ： 123drop index idx_emp_age_salary on emp;explain select age,count(*) from emp group by age; 优化后 1explain select age,count(*) from emp group by age order by null; 利用索引 ： 1create index idx_emp_age_salary on emp(age,salary)； 优化嵌套查询Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。 示例 ，查找有角色的所有的用户信息 : 1explain select * from t_user where id in (select user_id from user_role ); 执行计划为 : 优化后 : 1explain select * from t_user u , user_role ur where u.id = ur.user_id; 连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。 优化OR条件 增加索引。对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。 使用 union 替换 or 1select * from emp where id = 1 or id = 10 我们来比较下重要指标，发现主要差别是 type 和 ref 这两项 type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： 1system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距 UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快 这两项的差距就说明了 UNION 要优于 OR 。 优化分页查询一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。 优化思路一在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。 优化思路二该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。 使用SQL提示SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 USE INDEX在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。 1select * from tb_seller user index(idx_seller_name) where name = '小米科技'; IGNORE INDEX如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。 1select * from tb_seller ignore index(idx_seller_name) where name = '小米科技'; FORCE INDEX为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 1select * from tb_seller force index(idx_seller_address) where address = '北京市';","link":"/blog/2020/07/04/MySQL-index-use&SQL-optimized/"},{"title":"MyBatis","text":"Demo 导入相关依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt;&lt;/dependency&gt; 编写MyBatis核心配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 导入数据库连接的配置文件 --&gt; &lt;properties resource=\"db.properties\"/&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=\"com.atomsk.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写MyBatis工具类，便于使用 1234567891011121314151617181920public class MybatisUtils { private static SqlSessionFactory factory; static { try { //将 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); factory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { System.out.println(\"创建SqlSession工厂失败\"); e.printStackTrace(); } } public static SqlSession getSqlSession() { return factory.openSession(); }} 创建实体类 编写Mapper接口类 1234@Mapperpublic interface UserMapper { List&lt;User&gt; getAllUser();} 编写Mapper.xml配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.atomsk.dao.UserMapper\"&gt; &lt;select id=\"getAllUser\" resultType=\"com.atomsk.pojo.User\"&gt; select * from user; &lt;/select&gt;&lt;/mapper&gt; Mavan静态资源过滤 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 编写测试类 123456789101112public class UserMapperTest { @Test public void test() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.getAllUser(); for (User user : users) { System.out.println(user); } sqlSession.close(); }} CRUD select 参数： rersultType：SQL语句返回值类型。【完整的类名或者别名】 parameterType：传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 示例：根据 用户名 和 密码 查询用户 思路一：直接在方法中传递参数 1、在接口方法的参数前加 @Param属性 2、Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型 12345User selectUserByNP(@Param(\"username\") String username,@Param(\"password\") String pwd);&lt;select id=\"selectUserByNP\" resultType=\"com.kuang.pojo.User\"&gt; select * from user where name = #{username} and pwd = #{password}&lt;/select&gt; 思路二：使用万能的Map 1、在接口方法中，参数直接传递Map； 1User selectUserByNP2(Map&lt;String,Object&gt; map); 2、编写sql语句的时候，需要传递参数类型，参数类型为map 123&lt;select id=\"selectUserByNP2\" parameterType=\"map\" resultType=\"com.kuang.pojo.User\"&gt; select * from user where name = #{username} and pwd = #{password}&lt;/select&gt; 3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！ 1234Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();map.put(\"username\",\"小明\");map.put(\"password\",\"123456\");User user = mapper.selectUserByNP2(map); 总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可 insert update delete 操作需要提交事务！ 关于@Param @Param注解用于给方法参数起一个名字。以下是总结的使用原则： 在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是Javabean。 #与$的区别 #{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】 12INSERT INTO user (name) VALUES (#{name});INSERT INTO user (name) VALUES (?); ${} 的作用是直接进行字符串替换 12INSERT INTO user (name) VALUES ('${name}');INSERT INTO user (name) VALUES ('kuangshen'); 配置解析 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 能配置的内容如下： 12345678910111213configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器） 注意元素节点的顺序！顺序不对会报错 可以阅读 mybatis-config.xml 上面的dtd的头文件！ environments元素 12345678910111213141516171819&lt;configuration&gt; &lt;!--导入properties文件--&gt; &lt;properties resource=\"db.properties\"/&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定） 子元素节点：environment dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 有三种内建的数据源类型 1type=&quot;[UNPOOLED|POOLED|JNDI]&quot;） unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. mappers元素 mappers 引入资源方式 12345678910111213141516171819202122&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt;&lt;/mappers&gt;&lt;!--使用映射器接口实现类的完全限定类名需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt;&lt;/mappers&gt;&lt;!--将包内的映射器接口实现全部注册为映射器但是需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt;&lt;/mappers&gt; Mapper文件 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.kuang.mapper.UserMapper\"&gt; &lt;/mapper&gt; namespace中文意思：命名空间，作用如下： namespace的命名必须跟某个接口同名 接口中的方法与映射文件中sql语句id应该一一对应 typeAliases优化 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 1234&lt;!--配置别名,注意顺序--&gt;&lt;typeAliases&gt; &lt;typeAlias type=\"com.kuang.pojo.User\" alias=\"User\"/&gt;&lt;/typeAliases&gt; 当这样配置时，User可以用在任何使用com.kuang.pojo.User的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如: 123&lt;typeAliases&gt; &lt;package name=\"com.kuang.pojo\"/&gt;&lt;/typeAliases&gt; 每一个在包 com.kuang.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 若有注解，则别名为其注解值。见下面的例子： 1234@Alias(\"user\")public class User { ...} 日志如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。 对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。 Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具： SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging 具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。 标准日志实现指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;&lt;/settings&gt; 测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug Log4j简介： 通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件…. 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 使用步骤： 1、导入log4j的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 2、配置文件编写 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/kuang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 3、setting设置日志实现 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt;&lt;/settings&gt; 4、在程序中使用Log4j进行输出！ 12345678910111213141516//注意导包：org.apache.log4j.Loggerstatic Logger logger = Logger.getLogger(MyTest.class);@Testpublic void selectUser() { logger.info(\"info：进入selectUser方法\"); logger.debug(\"debug：进入selectUser方法\"); logger.error(\"error: 进入selectUser方法\"); SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users){ System.out.println(user); } session.close();} 5、测试，看控制台输出！ 使用Log4j 输出日志 可以看到还生成了一个日志的文件 【需要修改file的日志级别】 分页 limit实现分页 思考：为什么需要分页？ 在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。 使用Limit实现分页 1234567891011#语法SELECT * FROM table LIMIT stratIndex，pageSizeSELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 #为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. #如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行 #换句话说，LIMIT n 等价于 LIMIT 0,n。 步骤： 1、Mapper接口，参数为map 12//选择全部用户实现分页List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map); 2、修改Mapper文件 123&lt;select id=\"selectUser\" parameterType=\"map\" resultType=\"user\"&gt; select * from user limit #{startIndex},#{pageSize}&lt;/select&gt; 3、在测试类中传入参数测试 推断：起始位置 = （当前页面 - 1 ） * 页面大小 1​ int currentPage = 1; //第几页 int pageSize = 2; //每页显示几个 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(“startIndex”,(currentPage-1)*pageSize); map.put(“pageSize”,pageSize); List users = mapper.selectUser(map);​``` 1234567891011121314151617181920212223242526272829303132333435PageHelper官方文档：https://pagehelper.github.io/## 多对一的处理多对一的理解：- 多个学生对应一个老师- 如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！&gt; 数据库设计```mysqlCREATE TABLE `teacher` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, '秦老师');CREATE TABLE `student` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,`tid` INT(10) DEFAULT NULL,PRIMARY KEY (`id`),KEY `fktid` (`tid`),CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8 按结果嵌套处理 1234567891011121314&lt;select id=\"getStudents2\" resultMap=\"StudentTeacher2\" &gt; select s.id sid, s.name sname , t.name tname from student s,teacher t where s.tid = t.id&lt;/select&gt;&lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;id property=\"id\" column=\"sid\"/&gt; &lt;result property=\"name\" column=\"sname\"/&gt; &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 按查询嵌套处理 12345678910&lt;select id=\"getStudents\" resultMap=\"StudentTeacher\"&gt; select * from student&lt;/select&gt;&lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt; &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/&gt;&lt;/resultMap&gt;&lt;select id=\"getTeacher\" resultType=\"teacher\"&gt; select * from teacher where id = #{id}&lt;/select&gt; 一对多的处理一对多的理解： 一个老师拥有多个学生 如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！ 按结果嵌套处理 1234567891011121314&lt;select id=\"getTeacher\" resultMap=\"TeacherStudent\"&gt; select s.id sid, s.name sname , t.name tname, t.id tid from student s,teacher t where s.tid = t.id and t.id=#{id}&lt;/select&gt;&lt;resultMap id=\"TeacherStudent\" type=\"Teacher\"&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;collection property=\"students\" ofType=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\" /&gt; &lt;result property=\"name\" column=\"sname\" /&gt; &lt;result property=\"tid\" column=\"tid\" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按查询嵌套处理 123456789101112&lt;select id=\"getTeacher2\" resultMap=\"TeacherStudent2\"&gt; select * from teacher where id = #{id}&lt;/select&gt;&lt;resultMap id=\"TeacherStudent2\" type=\"Teacher\"&gt; &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt; &lt;collection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" column=\"id\" select=\"getStudentByTeacherId\"/&gt;&lt;/resultMap&gt;&lt;select id=\"getStudentByTeacherId\" resultType=\"Student\"&gt; select * from student where tid = #{id}&lt;/select&gt; 小结 按照查询进行嵌套处理就像SQL中的子查询 按照结果进行嵌套处理就像SQL中的联表查询 association是用于一对一和多对一，而collection是用于一对多的关系 JavaType和ofType都是用来指定对象类型的 ​ JavaType是用来指定pojo中属性的类型 ​ ofType指定的是映射到list集合属性中pojo的类型。 动态SQL 介绍 什么是动态SQL：动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句. if 和Where语句 修改上面的SQL语句； 1234567891011&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;if test=\"title != null\"&gt; title = #{title} &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #{author} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。 Set 同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？ 12345678910111213&lt;!--注意set是用的逗号隔开--&gt;&lt;update id=\"updateBlog\" parameterType=\"map\"&gt; update blog &lt;set&gt; &lt;if test=\"title != null\"&gt; title = #{title}, &lt;/if&gt; &lt;if test=\"author != null\"&gt; author = #{author} &lt;/if&gt; &lt;/set&gt; where id = #{id};&lt;/update&gt; choose语句 有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句 12345678910111213141516&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=\"title != null\"&gt; title = #{title} &lt;/when&gt; &lt;when test=\"author != null\"&gt; and author = #{author} &lt;/when&gt; &lt;otherwise&gt; and views = #{views} &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。 提取SQL片段： 12345678&lt;sql id=\"if-title-author\"&gt; &lt;if test=\"title != null\"&gt; title = #{title} &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #{author} &lt;/if&gt;&lt;/sql&gt; 引用SQL片段： 12345678&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt; &lt;include refid=\"if-title-author\"&gt;&lt;/include&gt; &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt; &lt;/where&gt;&lt;/select&gt; 注意： ①、最好基于 单表来定义 sql 片段，提高片段的可重用性 ②、在 sql 片段中不要包括 where Foreach 将数据库中前三个数据的id修改为1,2,3； 需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息 2、编写SQL语句 12345678910111213141516&lt;select id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from blog where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"&gt; id=#{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。 缓存 Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存： 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 一级缓存失效的四种情况 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！ 当前sqlSession的缓存中不存在这个数据 sqlSession相同，两次查询之间执行了增删改操作 sqlSession相同，手动清除了一级缓存，sqlSession.clearCache() 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 使用步骤 1、开启全局缓存 【mybatis-config.xml】 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】 123456781. &lt;cache/&gt;或者2. &lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt;这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 3、代码测试 所有的实体类先实现序列化接口 测试代码 123456789101112131415161718@Testpublic void testQueryUserById(){ SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.close(); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session2.close();} 结论 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 缓存原理图 EhCache 第三方缓存实现–EhCache:","link":"/blog/2020/07/13/mybatis/"},{"title":"MyBatis-Plus","text":"简介MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 代码托管：Gitee | Github 我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 框架结构 快速入门使用第三方组件：1、导入对应的依赖2、研究依赖如何配置3、代码如何编写4、提高扩展技术能力！ 快速开始1、创建数据库 mybatis_plus2、创建user表 123456789101112131415DROP TABLE IF EXISTS user;CREATE TABLE user(id BIGINT(20) NOT NULL COMMENT '主键ID',name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',age INT(11) NULL DEFAULT NULL COMMENT '年龄',email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',PRIMARY KEY (id));INSERT INTO user (id, name, age, email) VALUES(1, 'Jone', 18, 'test1@baomidou.com'),(2, 'Jack', 20, 'test2@baomidou.com'),(3, 'Tom', 28, 'test3@baomidou.com'),(4, 'Sandy', 21, 'test4@baomidou.com'),(5, 'Billie', 24, 'test5@baomidou.com') 3、编写项目，初始化项目！使用SpringBoot初始化！4、导入依赖 1234567891011121314151617181920212223242526272829303132333435&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 使用 mybatis-plus 可以节省我们大量的代码，尽量不要同时导入 mybatis 和 mybatis-plus5、配置数据库连接 12345678910111213spring: datasource: username: root password: **** url: jdbc:mysql://129.204.240.134:3306/mybatis_plus driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource dbcp2: initial-size: 5 max-total: 20 min-idle: 5 pool-prepared-statements: true max-open-prepared-statements: 20 6、准备实体类和mapper pojo 1234567@Datapublic class User { private Long id; private String name; private Integer age; private String email;} mapper接口 12345// 在对应的Mapper上面继承基本的类 BaseMapper@Repository // 代表持久层public interface UserMapper extends BaseMapper&lt;User&gt; { // 所有的CRUD操作都已经编写完成了,你不需要像以前的配置一大堆文件了！} 注意点：在主启动类上去扫描我们的mapper包下的所有接口，@MapperScan(&quot;com.atomsk.mapper&quot;) 7、测试类中测试 1234567891011@SpringBootTestclass mybatis-plusApplicationTests { @Autowired private UserMapper userMapper; @Test public void testSelect() { System.out.println((\"----- selectAll method test ------\")); List&lt;User&gt; userList = userMapper.selectList(null); userList.forEach(System.out::println); }} 日志配置123mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl CRUD扩展插入操作123456789@Testpublic void testInsert(){ User user = new User(); user.setName(\"atomsk\"); user.setAge(22); user.setEmail(\"atomsk@126.com\"); int result = userMapper.insert(user);//结果为受影响行数 System.out.println(user);//会自动回填id} 主键生成策略 默认为 ID_WORKER 全局的唯一id 分布式系统唯一id生成：https://www.cnblogs.com/haoxinyue/p/5208136.html 雪花算法： snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！ 配置为 AUTO 主键自增 在实体类id上增加 @TableId(type = IdType.AUTO)，或者将全局配置mybatis-plus.global-config.db-config.id-type设置为 AUTO 数据库主键字段一定要勾选上自增选项！ IdType源码 1234567public enum IdType { AUTO(0), NONE(1), INPUT(2), ASSIGN_ID(3), ASSIGN_UUID(4)} 更新操作123456789@Testpublic void testUpdate(){ User user = new User(); user.setId(6L); user.setName(\"范二林\"); user.setEmail(\"fanerlin@85.com\"); userMapper.updateById(user); System.out.println(user);} 可以看到日志，SQL是根据条件自动生成的 自动填充阿里巴巴开发手册几乎所有的表都要配置上gmt_create、gmt_modified！而且需要自动化！ 方式一：数据库级别 在表中新增字段 create_time、update_time，使用CURRENT_TIMESTAMP默认值，给update_time勾选更新选项 同步实体类，增加属性 12private Date createTime;private Date updateTime; 进行插入和更新操作后： 日志表明填充工作由数据库完成 方式二：代码级别 删除数据库字段的默认值和更新操作！ 实体类属性上增加注解： 1234@TableField(fill = FieldFill.INSERT)private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 3. 编写处理器来处理这个注解： 12345678910111213141516171819@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler { //插入时的填充策略 @Override public void insertFill(MetaObject metaObject) { log.info(\"start insert fill\"); this.setFieldValByName(\"createTime\", new Date(), metaObject); this.setFieldValByName(\"updateTime\", new Date(), metaObject); } //更新时的填充策略 @Override public void updateFill(MetaObject metaObject) { log.info(\"start update fill\"); this.setFieldValByName(\"updateTime\", new Date(), metaObject); }} 进行插入和更新操作后： 日志表面填充工作由MP完成 注意事项： 字段必须声明TableField注解,属性fill选择对应策略,该声明告知Mybatis-Plus需要预留注入SQL字段 填充处理器MyMetaObjectHandler在 Spring Boot 中需要声明@Component或@Bean注入 乐观锁乐观锁：故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试 悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！ 乐观锁实现方式： 取出记录时，获取当前 version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 1234567乐观锁：1、先查询，获得版本号 version = 1-- Aupdate user set name = \"kuangshen\", version = version + 1where id = 2 and version = 1-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！update user set name = \"kuangshen\", version = version + 1where id = 2 and version = 1 使用MP的乐观锁插件 给数据库增加version字段，类型为int，默认值为1 同步实体类 12@Versionprivate Integer version; 注册组件 optimisticLockerInterceptor 12345678910@MapperScan(\"com.atomsk.demo.mapper\")@EnableTransactionManagement@Configurationpublic class mybatis-plusConfig { //乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor(){ return new OptimisticLockerInterceptor(); }} 进行更新测试，日志输出： 123==&gt; Preparing: UPDATE user SET name=?, ... , version=? ... WHERE id=? AND version=? ==&gt; Parameters: atomsk(String), ... , 3(Integer), ... , 1(Long), 2(Integer)&lt;== Updates: 1 查询操作12345678910111213141516//测试批量查询@Testpublic void testSelectByBatchId() { List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println);}//按条件查询之使用map@Testpublic void testSelectByBatchIds() { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"atomsk\"); map.put(\"age\", 18); List&lt;User&gt; users = userMapper.selectByMap(map); users.forEach(System.out::println);} 分页查询 原始的limit进行分页 pageHelper第三方插件 MP内置的分页插件 如何使用 配置拦截器组件 12345//分页插件@Beanpublic PaginationInterceptor paginationInterceptor(){ return new PaginationInterceptor();} 直接使用Page对象即可 1234567@Testpublic void testPage(){ Page&lt;User&gt; page = new Page&lt;&gt;(1, 3); userMapper.selectPage(page, null); page.getRecords().forEach(System.out::println); System.out.println(page.getTotal());} 删除操作12345678910111213//通过id批量删除@Testpublic void testDeleteBatchId(){ userMapper.deleteBatchIds(Arrays.asList(1, 2, 3));}//通过map删除@Testpublic void testDeleteMap(){ HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"atomsk\"); userMapper.deleteByMap(map);} 逻辑删除物理删除：从数据库中直接移除 逻辑删除：在数据库中没有被移除，而是通过一个变量来让他失效，deleted=0 -&gt; deleted=1 使用 在数据库中增加一个deleted字段，类型为int，默认值为0 增加配置： 123456mybatis-plus: global-config: db-config: logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 实体类字段上增加注解： 12@TableLogicprivate Integer deleted; 测试 条件构造器详情请看：https://mp.baomidou.com/guide/wrapper.html AbstractWrapper多个方法间默认用AND拼接，使用OR时要显式调用 例: eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)—&gt;id = 1 or name = '老王' allEq（详见官网） in、notIn、between、notBetween，isNull、isNotNull：用法略 inSql、notInSql：子查询，也可以和in、notIn一样使用 值比较 eq ne gt ge lt le 等于 = 不等于 &lt;&gt; 大于 &gt; 大于等于 &gt;= 小于 &lt; 小于等于 &lt;= 以eq为例子： 1234567891011eq(R column, Object val)eq(boolean condition, R column, Object val)@Testvoid contextLoads() {QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper .isNotNull(\"name\") .eq(\"age\",22); userMapper.selectList(wrapper).forEach(System.out::println);} 模糊查询 like notLike likeLeft likeRight LIKE ‘%值%’ NOT LIKE ‘%值%’ LIKE ‘%值’ LIKE ‘值%’ 例子： 1234567891011@Testvoid test4(){ QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 左 %t 和右 t% wrapper .notLike(\"name\",\"a\") .likeRight(\"email\",\"t\"); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper); maps.forEach(System.out::println);} mybatis日志： 12==&gt; Preparing: SELECT id,name,age,... FROM user WHERE deleted=0 AND (name NOT LIKE ? AND email LIKE ?) ==&gt; Parameters: %a%(String), t%(String) 排序 orderBy orderByAsc orderByDesc ORDER BY 字段, … ORDER BY 字段, … ASC ORDER BY 字段, … DESC orderBy，第一个true表示加入sql，第二个true表示按升序排列 1orderBy(boolean condition, boolean isAsc, R... columns) 例: orderBy(true, true, &quot;id&quot;, &quot;name&quot;)—&gt;order by id ASC,name ASC orderByAsc和orderByDesc用法一样，以orderByAsc为例 12orderByAsc(R... columns)orderByAsc(boolean condition, R... columns) 排序：ORDER BY 字段, … ASC 例: orderByAsc(&quot;id&quot;, &quot;name&quot;)—&gt;order by id ASC,name ASC groupBy和Having12groupBy(R... columns)groupBy(boolean condition, R... columns) 分组：GROUP BY 字段, … 例: groupBy(&quot;id&quot;, &quot;name&quot;)—&gt;group by id,name 12having(String sqlHaving, Object... params)having(boolean condition, String sqlHaving, Object... params) HAVING ( sql语句 ) 例: having(&quot;sum(age) &gt; 10&quot;)—&gt;having sum(age) &gt; 10 例: having(&quot;sum(age) &gt; {0}&quot;, 11)—&gt;having sum(age) &gt; 11 QueryWrapper 说明: 继承自 AbstractWrapper ,自身的内部属性 entity 也用于生成 where 条件 select12345678@Testvoid testQuerryWrapper(){ QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.select(\"id,name,age\"); //或者 wrapper.select(\"id\",\"name\",\"age\"); List&lt;User&gt; users = userMapper.selectList(wrapper); users.forEach(System.out::println);} 代码生成器自动生成pojo、mapper、service、controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MPCodeGenerator { //读取控制台内容 public static String scanner(String tip) { Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\"请输入\" + tip + \"：\"); System.out.println(help.toString()); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) { return ipt; } } throw new mybatis-plusException(\"请输入正确的\" + tip + \"！\"); } public static void main(String[] args) { // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 1.全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/mybatis-plus-code-generator/src/main/java\"); gc.setAuthor(\"atomsk\"); gc.setOpen(false); gc.setFileOverride(false);//是否覆盖 gc.setServiceName(\"%sService\");//去Service的I前缀 gc.setIdType(IdType.AUTO); gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); //实体属性 Swagger2 注解 mpg.setGlobalConfig(gc); // 2.数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://129.204.240.134:3306/mybatis_plus\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"****\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 3.包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(scanner(\"模块名\")); pc.setParent(\"com.atomsk\"); mpg.setPackageInfo(pc); // 4.策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(scanner(\"表名，多个则用英文逗号分割\").split(\",\"));//设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); //自动lombok strategy.setVersionFieldName(\"version\");//乐观锁 strategy.setLogicDeleteFieldName(\"deleted\");//逻辑删除 //自动填充配置 TableFill createTime = new TableFill(\"create_time\", FieldFill.INSERT); TableFill updateTime = new TableFill(\"update_time\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(createTime); tableFills.add(updateTime); strategy.setTableFillList(tableFills); strategy.setRestControllerStyle(true);//生成@RestController strategy.setControllerMappingHyphenStyle(true);//生成@RequestMapping(\"/模块名/表名\") mpg.setStrategy(strategy); mpg.execute(); }} 生成的项目结构：","link":"/blog/2020/08/02/mybatis-plus/"},{"title":"设计模式之创建型模式","text":"创建型模式创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。 创建型模式分为以下几种。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式 单例（Singleton）模式参考博客地址 饿汉式饿汉模式，可以想象一个很饿的人，需要立马吃东西，饿汉模式便是这样，在类加载时就创建对象，由于在类加载时就创建单例，因此不存在线程安全问题 1234567891011121314151617public class Hungry { // 可能会浪费空间 private byte[] data1 = new byte[1024*1024]; private byte[] data2 = new byte[1024*1024]; private byte[] data3 = new byte[1024*1024]; private byte[] data4 = new byte[1024*1024]; private Hungry(){ } private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance(){ return HUNGRY; }} 如果在该类里面存在大量开辟空间的语句，但又不马上使用他们，这时这样的单例模式会消耗大量的内存，影响性能 懒汉式顾名思义，懒汉式，就是懒，即在类加载时并不会立马创建单例对象，而是只生成一个单例的引用，即可以延时加载 123456789101112131415public class LazyMan { private LazyMan() { } private static LazyMan instance; //提供公共的获取方法,因为不是在类加载时就创建对象，因此存在线程安全问题，使用synchronized关键字保证线程安全，效率降低 public static synchronized LazyMan getInstance() { if (instance == null) { instance = new LazyMan(); } return instance; }} 懒汉式使用同步锁锁住了整个方法，效率较低 DCL懒汉式(双重检测锁模式)参考博客地址 双重检测锁模式的关键点： 防止多线程重复创建——双重检测 避免实例化对象时指令重排——volatile关键字 123456789101112131415public class LazyMan { 2. private volatile static LazyMan lazyMan; 1. public static LazyMan getInstance(){ if (lazyMan==null){ synchronized (LazyMan.class){ if (lazyMan==null){ //不是一个原子性操作，所以要给对象加上volatile关键字 lazyMan = new LazyMan(); } } } return lazyMan; }} 由于JVM底层内部模型的原因，偶尔会出现问题，因此不建议使用 静态内部类使用静态内部类解决了线程安全问题，并实现了延时加载 12345678910public class Holder{ private Holder(){} public static Holder getInstance(){ return InnerClass.HOLDER; } public static calss InnerClass{ private static finnal Holder HOLDER=new Holder(); }} 对于以上四种实现单例模式的方式，都可以使用反射进行破坏，因此可以用一个随机标识位防止反射破坏，但不能阻止反编译破解 1234567891011private static boolean atomsk = false;private Singleton(){ synchronized (Singleton.class){ if (atomsk == false){ atomsk = true; }else { throw new RuntimeException(\"不要试图使用反射破坏异常\"); } }} 枚举单例使用枚举可以阻止反射，详见狂神说单例 123456public enum EnumSingle{ INSTANCE; public EnumSingle getInstance(){ return INSTANCE; }} 五种实现单例模式的方式的对比 饿汉式：线程安全（不排除反射），调用效率高，不能延时加载 懒汉式：线程安全（不排除反射）,调用效率不高，可以延时加载 DCL懒汉式：由于JVM底层模型原因，偶尔出现问题，不建议使用 静态内部类式：线程安全（不排除反射），调用效率高，可以延时加载 枚举单例：线程安全，调用效率高，不能延时加载 单例模式常见场景 Windows的任务管理器、回收站等 servlet中每个servlet都是单例 数据库连接池一般都是单例的 Spring中每个Bean都是单例的 原型（Prototype）模式原型模式的定义与特点原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。 原型模式的结构由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。 原型模式包含以下主要角色。 抽象原型类：规定了具体原型对象必须实现的接口。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 其结构图如图 1 所示。 图1 原型模式的结构图 原型模式的扩展原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。其结构图如图 2 所示。 图2 带原型管理器的原型模式的结构图 【例1】用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积。分析：本实例中由于存在不同的图形类，例如，“圆”和“正方形”，它们计算面积的方法不一样，所以需要用一个原型管理器来管理它们，图 3 所示是其结构图。 图3 图形生成器的结构图 建造者（Builder）模式模式的定义与特点建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 该模式的主要优点如下： 各个具体的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成的细节，便于控制细节风险。 其缺点如下： 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类。 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 模式的结构建造者（Builder）模式的主要角色如下。 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 模式的应用实例【例1】用建造者（Builder）模式描述客厅装修。 分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。 这里客厅是产品，包括墙、电视和沙发等组成部分。具体装修工人是具体建造者，他们负责装修与墙、电视和沙发的布局。项目经理是指挥者，他负责指挥装修工人进行装修。 其类图如图 4 所示。 图4 客厅装修的结构图 模式的应用场景建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。 模式的扩展建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。","link":"/blog/2020/07/10/design-patterns-creating/"},{"title":"设计模式之两种工厂模式","text":"工厂方法（FactoryMethod）模式模式的定义与特点工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。 我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。 工厂方法模式的主要优点有： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 模式的结构工厂方法模式的主要角色如下。 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 模式的应用实例【例1】用工厂方法模式设计畜牧场。 分析：有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛，所以该实例用工厂方法模式比较适合。 对养马场和养牛场等具体工厂类，只要定义一个生成动物的方法 newAnimal() 即可，并定义一个 show() 方法来显示它们。 其结构图如图 1 所示。 图1 畜牧场结构图 模式的应用场景工厂方法模式通常适用于以下场景。 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。 客户不关心创建产品的细节，只关心产品的品牌。 模式的扩展当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式，其结构图如图 2所示。 图2 简单工厂模式的结构图 抽象工厂（AbstractFactory）模式前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。 同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。 本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 13所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。 图3 电器工厂的产品等级与产品族 模式的定义与特点抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 使用抽象工厂模式一般要满足以下条件。 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。 系统一次只可能消费其中某一族产品，即同族的产品一起使用。 抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。 当增加一个新的产品族时不需要修改原代码，满足开闭原则。 其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。 模式的结构抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。 抽象工厂模式的主要角色如下。 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。 模式的应用实例【例1】用抽象工厂模式设计农场类。 分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，所以本实例比前面介绍的畜牧场类复杂，必须用抽象工厂模式来实现。 本例用抽象工厂模式来设计两个农场，一个是韶关农场用于养牛和种菜，一个是上饶农场用于养马和种水果，可以在以上两个农场中定义一个生成动物的方法 newAnimal() 和一个培养植物的方法 newPlant()。 其结构图如图 4 所示。 图4 农场类的结构图 模式的应用场景抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。 抽象工厂模式通常适用于以下场景： 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。 模式的扩展抽象工厂模式的扩展有一定的“开闭原则”倾斜性： 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。 另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。 工厂方法和抽象工厂的区别来源：抽象工厂、工厂方法和简单工厂的不同点及使用心得 抽象工厂模式​ 假设有m家工厂，n种部件，如果按照抽象工厂模式去设计的话，最终将会有1个抽象工厂接口（客户端用来初始化并决定具体用哪家工厂去生产产品），n个抽象部件接口（定义每个部件的规范标准，这些标准在各个工厂下都是一样的），m个具体工厂类（每个工厂有n个方法，用来初始化n个具体部件生产类），m*n个具体部件类（这些类是真正生产产品的类）。 【例2】1个抽象工厂接口，2个部件（手机和路由器)不同厂商对应产品 抽象工厂对于变化的封装： 如果要切换工厂，只需要在最开始初始化工厂类的时候换另一家工厂就好了，而整个结构都无需改动。 如果增加部件，抽象工厂接口以及其子工厂都需要添加能生产此部件的方法，同时还需要添加一个此部件的抽象接口以及每种工厂生产这种部件的具体方法，好处是已有的部件类不需要改动。 如果增加工厂，首先需要增加此工厂并实现抽象工厂类，同时需要在每个抽象部件那里加一个此工厂生产对应部件的具体类，好处是已有工厂类和部件类都不需要改动。 综上所述，抽象工厂模式基本上完美的遵循了开放封闭原则，即使第二种情况需要修改已有的工厂类，但由于工厂类的职责是去初始化并返回一个真正的部件生产类，因此已有的核心类部件类依然没有因为扩展而做过任何修改。 工厂方法模式​ 工厂方法可以说是抽象工厂的一个特例，当工厂里只有一种产品的时候，抽象工厂的结构就简化成工厂方法的结构了。此时会有一个抽象工厂接口，一个抽象产品接口，假设还是有m家工厂，那么会有m个具体工厂类，同时有m个具体产品类，工厂类和产品类是一一对应的关系，每个工厂类负责去初始化其对应的产品类。 ​ 工厂方法也是符合开放封闭原则的，如果再加一个新的工厂，只需要增加一个工厂类和此工厂生产产品的具体类就OK了，其他工厂类和产品类都无需改动。 简单工厂模式​ 简单工厂模式并没有AbstractFactory接口，它是根据参数或者配置文件等事先定义好的变量，然后利用分支判断或者反射技术来动态的初始化具体产品类并返回。它的产品类接口和数量与其他两种工厂模式一样，不同的地方在于它没有那么多的工厂类，可以只用一个静态工厂类来生成想要的产品。 由于增加工厂或者产品都需要修改静态工厂类，因此它不符合开放封闭原则。好处是大大减少了工厂类，若使用了反射技术，也会减少很多判断分支代码量。 使用场景总结​ 如果产品单一，并且客户端在创建产品实例时需要用灵活的参数来指定具体使用哪种工厂，那么可以优先使用简单工厂；若客户端相对稳定的指定一种工厂，同时在多个地方用此工厂创建产品类，则优先考虑用工厂方法模式。如果产品有多种，则考虑使用抽象工厂模式。需要注意的是抽象工厂模式里的工厂类既可以用工厂方法来实现，此时是标准的抽象工厂模式；也可用简单工厂来实现，这种情况一般是用一个静态工厂类和多个静态方法来代替那一大堆的工厂类，工厂种类的指定可以用常量或配置文件，并且在一定的环境下相对稳定。","link":"/blog/2020/07/10/design-patterns-factory/"},{"title":"设计模式之代理模式","text":"参考及来源：狂神说 代理模式的定义与特点代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 代理模式的主要优点有： 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 其主要缺点是： 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 增加了系统的复杂度； 代理模式的结构与实代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。 代理模式的主要角色如下。 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 其结构图如图 1 所示。 图1 代理模式的结构图 静态代理静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 应用实例：租房 123456789101112131415161718192021222324252627282930313233343536373839404142434445//抽象角色：租房public interface Rent { public void rent();}//真实角色: 房东，房东要出租房子public class Host implements Rent{ public void rent() { System.out.println(\"房屋出租\"); }}//代理角色：中介public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房 public void rent(){ seeHouse(); host.rent(); fare(); } public void seeHouse(){ System.out.println(\"带房客看房\"); } public void fare(){ System.out.println(\"收中介费\"); }}//客户public class Client { public static void main(String[] args) { //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); }} 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。 静态代理的好处 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 公共的业务由代理来完成 . 实现了业务的分工 公共业务发生扩展时变得更加集中和方便 缺点 :类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! 动态代理 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理—-JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 JDK的动态代理InvocationHandler是代理实例的调用处理程序需要实现的接口，只有一个方法 1Object invoke(Object proxy, Method method, Object[] args)； 参数： proxy - 调用该方法的代理实例 method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口 args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 Proxy该类即为动态代理类，提供了创建动态代理类和实例的静态方法： static Class getProxyClass (ClassLoaderloader, Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。 static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法) 所谓DynamicProxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些 interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。 通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。 代码实现 抽象角色和真实角色和之前的一样 ProxyInvocationHandler. java 即代理角色 12345678910111213141516171819202122232425262728293031323334public class ProxyInvocationHandler implements InvocationHandler { private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; } //看房 public void seeHouse(){ System.out.println(\"带房客看房\"); } //收中介费 public void fare(){ System.out.println(\"收中介费\"); }} Client . java 1234567891011121314//租客public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); }} 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、 动态代理的好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！","link":"/blog/2020/07/28/design-patterns-proxy/"},{"title":"设计模式——适配器模式和桥接模式","text":"结构型模式结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 结构型模式分为以下 7 种： 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式，下面我们会分别、详细地介绍它们的特点、结构与应用。 适配器（Adapter）模式模式的定义与特点适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 该模式的主要优点如下。 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。 模式的结构与实现类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。 1. 模式的结构适配器模式（Adapter）包含以下主要角色。 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 类适配器模式的结构图如图 1 所示。 图1 类适配器模式的结构图 对象适配器模式的结构图如图 2 所示。 图2 对象适配器模式的结构图 2. 模式的实现(1) 类适配器模式的代码如下。 1234567891011121314151617181920212223242526272829303132package adapter;//目标接口interface Target{ public void request();}//适配者接口class Adaptee{ public void specificRequest() { System.out.println(\"适配者中的业务代码被调用！\"); }}//类适配器类class ClassAdapter extends Adaptee implements Target{ public void request() { specificRequest(); }}//客户端代码public class ClassAdapterTest{ public static void main(String[] args) { System.out.println(\"类适配器模式测试：\"); Target target = new ClassAdapter(); target.request(); }} 程序的运行结果如下： 12类适配器模式测试：适配者中的业务代码被调用！ (2)对象适配器模式的代码如下。 12345678910111213141516171819202122232425package adapter;//对象适配器类class ObjectAdapter implements Target{ private Adaptee adaptee; public ObjectAdapter(Adaptee adaptee) { this.adaptee=adaptee; } public void request() { adaptee.specificRequest(); }}//客户端代码public class ObjectAdapterTest{ public static void main(String[] args) { System.out.println(\"对象适配器模式测试：\"); Adaptee adaptee = new Adaptee(); Target target = new ObjectAdapter(adaptee); target.request(); }} 说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。 程序的运行结果如下： 12对象适配器模式测试：适配者中的业务代码被调用！ 模式的应用场景适配器模式（Adapter）通常适用于以下场景。 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 模式的扩展适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图 3 所示。 图3 双向适配器模式的结构图 桥接（Bridge）模式桥接模式的定义与特点桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 桥接（Bridge）模式的优点是： 由于抽象与实现分离，所以扩展能力强； 其实现细节对客户透明。 缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 桥接模式的结构可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。 桥接（Bridge）模式包含以下主要角色。 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。 桥接模式的应用实例【例1】用桥接（Bridge）模式模拟女士皮包的选购。 分析：女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适。 本实例按用途分可选钱包（Wallet）和挎包（HandBag），按颜色分可选黄色（Yellow）和红色（Red）。可以按两个维度定义为颜色类和包类。 颜色类（Color）是一个维度，定义为实现化角色，它有两个具体实现化角色：黄色和红色，通过 getColor() 方法可以选择颜色；包类（Bag）是另一个维度，定义为抽象化角色，它有两个扩展抽象化角色：挎包和钱包，它包含了颜色类对象，通过 getName() 方法可以选择相关颜色的挎包和钱包。 该例子结构图如图 3 所示。 图3 女士皮包选购的结构图 程序代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//实现化角色：颜色interface Color{ String getColor();}//具体实现化角色：黄色class Yellow implements Color{ public String getColor() { return \"yellow\"; }}//具体实现化角色：红色class Red implements Color{ public String getColor() { return \"red\"; }}//抽象化角色：包abstract class Bag{ protected Color color; public void setColor(Color color) { this.color=color; } public abstract String getName();}//扩展抽象化角色：挎包class HandBag extends Bag{ public String getName() { return color.getColor()+\"HandBag\"; } }//扩展抽象化角色：钱包class Wallet extends Bag{ public String getName() { return color.getColor()+\"Wallet\"; } } 桥接模式的应用场景桥接模式通常适用于以下场景。 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。 桥接模式模式的扩展在软件开发中，有时桥接（Bridge）模式可与适配器模式联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如图 4 所示。 图4 桥接模式与适配器模式联用的结构图","link":"/blog/2020/07/09/design-patterns-structure/"},{"title":"设计模式概述","text":"笔记整理自C语言中文网 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 设计模式分类设计模式有两种分类方法，即根据模式的目的和作用的范围来分。 范围\\目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法 (类）适配器 模板方法、解释器 对象模式 单例 原型 抽象工厂 建造者 代理 (对象）适配器 桥接 装饰 外观 享元 组合 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录 根据目的来分根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 根据作用范围来分根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 OOP七大设计原则开闭原则开闭原则（Open Closed Principle，OCP）的含义是：当应用的需求改变时，在不修改软件实体的源代码的前提下，可以扩展模块的功能，使其满足新的需求。 核心思想：对扩展开发，对修改关闭 开闭原则的作用 对软件测试的影响 软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。 可以提高代码的可复用性 粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。 可以提高软件的可维护性 遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。 开闭原则的实现方法可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。 里氏替换原则里氏替换原则（Liskov Substitution Principle，LSP）主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。 核心思想：子类可以扩展父类的功能，但不能改变父类原有的功能，也要尽量避免重写父类的方法 里氏替换原则的作用里氏替换原则的主要作用如下。 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。 里氏替换原则的实现方法里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。 【例1】里氏替换原则在“几维鸟不是鸟”实例中的应用。 分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 1 所示。 图1 “几维鸟不是鸟”实例的类图 如果按照该类图设计程序，将会出现运行错误，原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。其类图如图 2 所示。 图2 “几维鸟是动物”实例的类图 --- 依赖倒置原则依赖倒置原则（Dependence Inversion Principle，DIP）的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象 核心思想：要面向接口编程，不要面向实现编程 依赖、倒置原则的作用 依赖倒置原则可以降低类间的耦合性。 依赖倒置原则可以提高系统的稳定性。 依赖倒置原则可以减少并行开发引起的风险。 依赖倒置原则可以提高代码的可读性和可维护性。 依赖倒置原则的实现方法依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。 每个类尽量提供接口或抽象类，或者两者都具备。 变量的声明类型尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 使用继承时尽量遵循里氏替换原则。 【例1】不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码，其类图如图 1 所示。 图1 顾客购物程序的类图 --- 单一职责原则单一职责原则（Single Responsibility Principle，SRP），该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 核心思想：控制类的粒度大小、将对象解耦、提高其内聚性。 单一职责原则的优点 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。 提高类的可读性。复杂性降低，自然其可读性会提高。 提高系统的可维护性。可读性提高，那自然更容易维护了。 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。 单一职责原则的实现方法单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。 【例1】大学学生工作管理程序。 分析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做 法是生活辅导由辅导员负责，学业指导由学业导师负责，其类图如图 1 所示。 图1 大学学生工作管理程序的类图 注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。 接口隔离原则接口隔离原则（Interface Segregation Principle，ISP）的定义是：客户端不应该被迫依赖于它不使用的方法，该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上 核心思想：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 接口隔离原则的优点接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。 接口隔离原则的实现方法在具体应用接口隔离原则时，应该根据以下几个规则来衡量。 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 【例1】学生成绩管理程序。 分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中，其类图如图 1 所示。 图1 学生成绩管理程序的类图 --- 迪米特法则迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，其定义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 核心思想：要与你的直接朋友交谈，不跟“陌生人”说话 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。 迪米特法则的优点迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。 但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 迪米特法则的实现方法从迪米特法则的定义和特点可知，它强调以下两点： 从依赖者的角度来说，只依赖应该依赖的对象。 从被依赖者的角度说，只暴露应该暴露的方法。 所以，在运用迪米特法则时要注意以下 6 点。 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。 在类的结构设计上，尽量降低类成员的访问权限。 在类的设计上，优先考虑将一个类设置成不变类。 在对其他类的引用上，将引用其他对象的次数降到最低。 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。 谨慎使用序列化（Serializable）功能。 【例1】明星与经纪人的关系实例。 分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如图 1 所示。 图1 明星与经纪人的关系图 --- 合成复用原则合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP） 核心思想：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 合成复用原则的重要性通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 合成复用原则的实现方法合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。 【例1】汽车分类管理程序。 分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 1 所示是用继淨：关系实现的汽车分类的类图。 图1 用继承关系实现的汽车分类的类图 从图 1 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。 图2 用组合关系实现的汽车分类的类图 --- 小结以上 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。","link":"/blog/2020/07/09/design-patterns-summery/"},{"title":"HTTP概述","text":"基于HTTP的组件系统HTTP是一个client-server协议：请求通过一个实体被发出，实体也就是用户代理。大多数情况下，这个用户代理都是指浏览器，当然它也可能是任何东西，比如一个爬取网页生成维护搜索引擎索引的机器爬虫。 每一个发送到服务器的请求，都会被服务器处理并返回一个消息，也就是response。在这个请求与响应之间，还有许许多多的被称为proxies的实体，他们的作用与表现各不相同，比如有些是网关，还有些是caches等。 实际上，在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机。由于Web的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP位于最上层的应用层。虽然底层对于分析网络问题非常重要，但是大多都跟对HTTP的描述不相干。 客户端user-agent 就是任何能够为用户发起行为的工具。这个角色通常都是由浏览器来扮演。一些例外情况，比如是工程师使用的程序，以及Web开发人员调试应用程序。 浏览器总是作为发起一个请求的实体，他永远不是服务器（虽然近几年已经出现一些机制能够模拟由服务器发起的请求消息了）。 要展现一个网页，浏览器首先发送一个请求来获取页面的HTML文档，再解析文档中的资源信息发送其他请求，获取可执行脚本或CSS样式来进行页面布局渲染，以及一些其它页面资源（如图片和视频等）。然后，浏览器将这些资源整合到一起，展现出一个完整的文档，也就是网页。浏览器执行的脚本可以在之后的阶段获取更多资源，并相应地更新网页。 一个网页就是一个超文本文档。也就是说，有一部分显示的文本可能是链接，启动它（通常是鼠标的点击）就可以获取一个新的网页，使得用户可以控制客户端进行网上冲浪。浏览器来负责发送HTTP请求，并进一步解析HTTP返回的消息，以向用户提供明确的响应。 Web服务端在上述通信过程的另一端，是由Web Server来服务并提供客户端所请求的文档。Server只是虚拟意义上代表一个机器：它可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 …）发起请求来获取部分或全部资源。 Server 不一定是一台机器，但一个机器上可以装载的众多Servers。在HTTP/1.1 和Host头部中，它们甚至可以共享同一个IP地址。 代理（Proxies）在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是透明的，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为代理（Proxies）。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）。代理主要有如下几种作用： 缓存（可以是公开的也可以是私有的，像浏览器的缓存） 过滤（像反病毒扫描，家长控制…） 负载均衡（让多个服务器服务不同的请求） 认证（对不同资源进行权限管理） 日志记录（允许存储历史信息） HTTP的基本性质HTTP 是简单的虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。 HTTP 是可扩展的在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。 HTTP 是无状态，有会话的 HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。 注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。 HTTP 和连接一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。 在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接，打开一个 TCP 连接需要多次往返交换消息（因此耗时）。HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 链接更低效。 为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。 为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议QUIC。 HTTP能控制什么多年以来，HTTP良好的扩展性使得越来越多的Web功能归其控制。缓存和认证很早就可以由HTTP来控制了。另一方面，对同源同域的限制到2010年才有所改变。 以下是可以被HTTP控制的常见特性。 缓存 文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。 开放同源限制为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。 认证一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用Authenticate相似的头部即可，或用HTTP Cookies来设置指定的会话。 代理和隧道通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。 会话使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。 HTTP流当客户端想要和服务端进行信息交互时（服务端是指最终服务器，或者是一个中间代理），过程表现为下面几步： 打开一个TCP连接：TCP连接被用来发送一条或多条请求，以及接受响应消息。客户端可能打开一条新的连接，或重用一个已经存在的连接，或者也可能开几个新的TCP连接连向服务端。 发送一个HTTP报文：HTTP报文（在HTTP/2之前）是语义可读的。在HTTP/2中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。 123GET / HTTP/1.1Host: developer.mozilla.orgAccept-Language: fr 读取服务端返回的报文信息： 12345678910HTTP/1.1 200 OKDate: Sat, 09 Oct 2010 14:28:02 GMTServer: ApacheLast-Modified: Tue, 01 Dec 2009 20:18:22 GMTETag: \"51142bc1-7449-479b075b2891b\"Accept-Ranges: bytesContent-Length: 29769Content-Type: text/html&lt;!DOCTYPE html... (here comes the 29769 bytes of the requested web page) 关闭连接或者为后续请求重用连接。 当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的帧所取代。 HTTP报文HTTP/1.1以及更早的HTTP协议报文都是语义可读的。在HTTP/2中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文头部的压缩和复用。即使只有原始HTTP报文的一部分以HTTP/2发送出来，每条报文的语义依旧不变，客户端会重组原始HTTP/1.1请求。因此用HTTP/1.1格式来理解HTTP/2报文仍旧有效。 有两种HTTP报文的类型，请求与响应，每种都有其特定的格式。 请求HTTP请求的一个例子： 请求由以下元素组成： 一个HTTP的method，经常是由一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送HTML form表单值（POST方法），虽然在一些情况下也会有其他操作。 要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有protocol （http://），domain（developer.mozilla.org），或是TCP的port（HTTP一般在80端口）。 HTTP协议版本号。 为服务端表达其他信息的可选头部headers。 对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似。 响应HTTP响应的一个例子： 响应报文包含了下面的元素： HTTP协议版本号。 一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。 一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。 HTTP headers，与请求头部类似。 可选项，比起请求报文，响应报文中更常见地包含获取的资源body。 基于HTTP的APIs基于HTTP的最常用API是XMLHttpRequest API，可用于在user agent和服务器之间交换数据。 现代Fetch API提供相同的功能，具有更强大和灵活的功能集。 另一种API，即服务器发送的事件，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件。 使用EventSource接口，客户端打开连接并建立事件句柄。 客户端浏览器自动将到达HTTP流的消息转换为适当的Event对象，并将它们传递给专门处理这类type事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给onmessage事件处理程序处理。","link":"/blog/2020/05/28/HTTP-Intro/"},{"title":"Vue基础","text":"Vue.js是什么?是一位华裔工程师（尤雨溪）开发的前端js库 特点： 遵循MVVM模式 编码简洁, 体积小, 运行效率高, 移动/PC端开发 它本身只关注UI, 可以轻松引入vue插件和其它第三库开发项目 vue常用的组件库： vue-cli: vue脚手架 vue-resource(axios): ajax请求 vue-router: 路由 vuex: 状态管理 vue-lazyload: 图片懒加载 vue-scroller: 页面滑动相关 mint-ui: 基于vue的组件库(移动端) element-ui: 基于vue的组件库(PC端) 基本使用123456789101112131415161718192021&lt;div id=\"test\"&gt; &lt;input type=\"text\" v-model=\"msg\"&gt;&lt;br&gt; &lt;p&gt;hello {{msg}}&lt;/p&gt;&lt;br&gt; &lt;a v-bind:href=\"url\"&gt;访问指定站点&lt;/a&gt;&lt;br&gt; &lt;button v-on:click=\"test(\"atomsk\")\"&gt;v-on测试&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el: '#test', data: { msg: 'vue', url: 'https://atomskgit.github.io/blog' }, methods: { test (name) { alert(name + '你好啊!!!') } } })&lt;/script&gt; vm里的属性： el：指定dom标签容器的选择器，vue就会管理对应标签及其字标签 data：初始化数据 双大括号表达式 v-xxx指令： 双向数据绑定：v-model=”msg” 强制数据绑定：v-bind:href=”url”，可简写成 :href=”url” 绑定事件监听：v-on:click=”test”，可简写成 @click=”test” 计算属性和监视属性计算属性 在computed属性对象中定义计算属性的方法，在页面中用 显示结果利用getter/setter方法实现对属性数据的显示和监视 有缓存，多次读取只执行一次getter 监视属性 通过通过 vm 对象的$watch()或 watch 属性对象配置来监视指定的属性 当属性变化时, 回调函数自动调用, 在函数内部进行计算 computed和watch对比： 12345678910111213141516171819202122232425262728293031 姓: &lt;input type=\"text\" placeholder=\"First Name\" v-model=\"firstName\"&gt;&lt;br&gt; 名: &lt;input type=\"text\" placeholder=\"Last Name\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名1: &lt;input type=\"text\" placeholder=\"Full Name1\" v-model=\"fullName1\"&gt;&lt;br&gt; 姓名2: &lt;input type=\"text\" placeholder=\"Full Name2\" v-model=\"fullName2\"&gt;&lt;br&gt;&lt;script&gt;computed: { fullName1: { // 当获取当前属性值时自动调用, 将返回值作为属性值 get () { return this.firstName + '-' + this.lastName }, // 当属性值发生了改变时自动调用 set (value) {//value即当前监视属性的值 const names = value.split('-') this.firstName = names[0] this.lastName = names[1] } }//watch的第一种形式watch: { // 配置监视firstName firstName: function (value) { this.fullName2 = value + '-' + this.lastName } }//watch的第二种形式vm.$watch('lastName', function (value) { this.fullName2 = this.firstName + '-' + value })&lt;/script&gt; 绑定class和style1234567&lt;!--class的三种形式 --&gt;&lt;p :class=\"myclass\"&gt;表达式是字符串&lt;/p&gt;&lt;p :class=\"{classA: hasClassA, classB: hasClassB}\"&gt;表达式是对象&lt;/p&gt;&lt;p :class=\"['classA', 'classC']\"&gt; 表达式是数组&lt;/p&gt;&lt;!--style --&gt;&lt;p :style=\"{color:activeColor, fontSize: fontSize}\"&gt;&lt;/p&gt;&lt;button @click=\"update\"&gt;更新&lt;/button&gt; 改变对应的变量即可： 1234567891011&lt;script&gt; methods: { update () { this.myClass = 'classB' this.hasClassA = true this.hasClassB = !hasClassB this.activeColor = 'red' this.fontSize = '30px' } }&lt;/script&gt; 生命周期详见：https://www.jianshu.com/p/4d3e554269c1 一些干货使用 v-for遍历对象，第一个参数是值，第二个参数是键 12345&lt;ul&gt; &lt;li v-for=\"(p, index) in persons\" :key=\"index\"&gt; {{index}}--{{p.name}}--{{p.age}} &lt;/li&gt;&lt;/ul&gt; 事件修饰符： @click.prevent=”xxx”：阻止事件的默认行为，即 event.preventDefault() @click.stop =”xxx”：停止事件冒泡，即 event.stopPropagation() 按键修饰符：@keydown.按键码/常用按键名=”xxx”。使用：给密码输入框或者验证码输入框加上sumbit方法 过滤器：对要显示的数据进行特定格式化后再显示 12345678定义:Vue.filter(filterName, function(value[,arg1,arg2,...]){ // 进行一定的数据处理 return newValue})使用：&lt;div&gt;{{myData | filterName}}&lt;/div&gt;&lt;div&gt;{{myData | filterName(arg)}}&lt;/div&gt; 其他指令： ref : 为某个元素注册一个唯一标识, vue对象通过$refs属性访问这个元素对象 v-cloak : 主要用于隐藏未被vue解析到的元素, 在style里加上: [v-cloak] { display: none }","link":"/blog/2020/05/30/Vue-base/"},{"title":"SpringMVC","text":"回顾MVC什么是MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 回顾Servlet 新建一个Maven工程当做父工程！pom依赖！ 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ 编写一个Servlet类，用来处理用户的请求 12345678910111213141516package com.kuang.servlet;public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getParameter(\"method\"); if (method.equals(\"add\")){ req.getSession().setAttribute(\"msg\",\"执行了add方法\"); } if (method.equals(\"delete\")){ req.getSession().setAttribute(\"msg\",\"执行了delete方法\"); } req.getRequestDispatcher(\"/WEB-INF/jsp/hello.jsp\").forward(req,resp); }} 编写hello.jsp 在web.xml中注册Servlet 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atomsk.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置Tomcat，并启动测试 MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 什么是SpringMVCSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 中心控制器Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能 DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类) SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 配置版1、新建一个Moudle， 添加Web app的支持 2、配置web.xml ， 注册DispatcherServlet 12345678910111213141516&lt;!-- 注册DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 处理器映射器 --&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; &lt;!-- 处理器适配器 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 4、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 1234567891011public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { ModelAndView mv = new ModelAndView(); //封装对象,Model mv.addObject(\"msg\",\"HelloSpringMVC!\"); //封装要跳转的视图,View mv.setViewName(\"hello\"); return mv; }} 5、将自己的类交给SpringIOC容器，注册bean 1&lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt; 6、准备jsp页面 7、配置Tomcat，开启服务器，访问对应的请求路径！ 注意增加lib文件夹并加入依赖包： 注解版 新建一个Moudle， 添加Web app的支持 配置web.xml，和配置版一样，略 / 和 /* 的区别 &lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错 添加Spring MVC配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"com.atomsk.controller\"/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt;&lt;/beans&gt; &lt;mvc:annotation-driven /&gt;说明：开启支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系要想使@RequestMapping注解生效，必须向上下文中注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerAdapter实例这两个实例分别在类级别和方法级别处理。而annotation-driven配置帮助我们自动完成上述两个实例的注入。 视图存放位置 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 创建Controller 123456789101112@Controller@RequestMapping(\"/atomsk\")public class HelloController { //真实访问地址 : 项目名/atomsk/hello @RequestMapping(\"/hello\") public String sayHello(Model model){ //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(\"msg\",\"hello,SpringMVC\"); //web-inf/jsp/hello.jsp return \"hello\"; }} 代码说明： @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置’ 结果跳转方式ServletAPI通过设置ServletAPI , 不需要视图解析器 . 1、通过HttpServletResponse进行输出 2、通过HttpServletResponse实现重定向 3、通过HttpServletResponse实现转发 123456789101112131415161718192021@Controllerpublic class ResultGo { @RequestMapping(\"/result/t1\") public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.getWriter().println(\"Hello,Spring BY servlet API\"); } @RequestMapping(\"/result/t2\") public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.sendRedirect(\"/index.jsp\"); } @RequestMapping(\"/result/t3\") public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception { //转发 req.setAttribute(\"msg\",\"/result/t3\"); req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,rsp); }} ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 12345678&lt;!-- 视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 对应的controller类 12345678910public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; }} SpringMVC通过SpringMVC来实现转发和重定向 ； 1234567891011121314151617181920public class ResultSpringMVC { //没有视图解析器的情况 @RequestMapping(\"/rsm/t1\") public String test1() { //转发 return \"/index.jsp\"; //重定向 return \"redirect:/index.jsp\"; } //有视图解析器的情况 @RequestMapping(\"/rsm/t2\") public String test2() { //转发 return \"test\"; //重定向 return \"redirect:/index.jsp\"; }} 数据处理处理提交数据1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : 12345@RequestMapping(&quot;/hello&quot;)public String hello(String name){ System.out.println(name); return &quot;hello&quot;;} 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : 12345@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name){ System.out.println(name); return &quot;hello&quot;;} 后台输出 : kuangshen 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 1、实体类 123456@Datapublic class User { private int id; private String name; private int age;} 2、提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 3、处理方法 : 12345@RequestMapping(&quot;/user&quot;)public String user(User user){ System.out.println(user); return &quot;hello&quot;;} 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView 略 第二种 : 通过ModelMap 12345678@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;name&quot;,name); System.out.println(name); return &quot;hello&quot;;} 第三种 : 通过Model 12345678@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;msg&quot;,name); System.out.println(name); return &quot;test&quot;;} 对比就对于新手而言简单来说使用区别就是： 12345Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 乱码问题以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 . 处理方法 : 1、修改tomcat配置文件 ：设置编码！ 123&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 2、自定义过滤器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*** 解决get和post请求 全部乱码的过滤器*/public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(\"text/html;charset=UTF-8\"); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { }}//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) { super(request);// super必须写 this.request = request; } // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() { // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(\"post\")) { // post请求 try { // 处理post乱码 request.setCharacterEncoding(\"utf-8\"); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(\"get\")) { // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i &lt; values.length; i++) { try { // 处理get乱码 values[i] = new String(values[i] .getBytes(\"ISO-8859-1\"), \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值 @Override public String getParameter(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值 } //取所有值 @Override public String[] getParameterValues(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; }} 这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ JSON JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的var json = '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse('{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}');//结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify({a: 'Hello', b: 'World'});//结果是 '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}' Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 12345678910&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml，配置DispatcherServlet和CharacterEncodingFilter springmvc-servlet.xml，开启mvc注解支持和默认的servlet handler，配置视图解析器，包扫描 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； 1234567891011//需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User { private String name; private int age; private String sex; } 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； 1234567891011121314151617@Controllerpublic class UserController { @RequestMapping(\"/json1\") @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; }} 配置Tomcat ， 启动测试一下！ 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 12//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 再次测试， 乱码问题解决！ 乱码统一解决上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 在类上使用 @RestController 代替@Controller，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ 启动tomcat测试，结果都正常输出！ 集合输出123456789101112131415161718@RequestMapping(\"/json2\")public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;} 时间对象输出1234@RequestMapping(\"/json3\")public String json3() throws JsonProcessingException { return new ObjectMapper().writeValueAsString(new Date(););;} 运行结果 :格式不对！ 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 123456789101112@RequestMapping(\"/json4\")public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //指定日期格式 mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); return mapper.writeValueAsString(new Date()); }} 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 12345678910111213141516171819202122public class JsonUtils { public static String getJson(Object object) { return getJson(object, \"yyyy-MM-dd HH:mm:ss\"); } public static String getJson(Object object, String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; }} 我们使用工具类，代码就更加简洁了！ FastJsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.70&lt;/version&gt;&lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 123456789101112131415161718192021222324252627282930public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); System.out.println(\"*******Java对象 转 JSON字符串*******\"); String str1 = JSON.toJSONString(list); System.out.println(\"JSON.toJSONString(list)==&gt;\"+str1); String str2 = JSON.toJSONString(user1); System.out.println(\"JSON.toJSONString(user1)==&gt;\"+str2); System.out.println(\"\\n****** JSON字符串 转 Java对象*******\"); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\"JSON.parseObject(str2,User.class)==&gt;\"+jp_user1); System.out.println(\"\\n****** Java对象 转 JSON对象 ******\"); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\"(JSONObject) JSON.toJSON(user2)==&gt;\"+jsonObject1.getString(\"name\")); System.out.println(\"\\n****** JSON对象 转 Java对象 ******\"); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\"JSON.toJavaObject(jsonObject1, User.class)==&gt;\"+to_java_user); }} 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！ Ajax 简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 jQuery.ajax纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ 123456789101112131415161718192021jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 &quot;xml&quot;: 将服务器端返回的内容转换成xml格式 &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式 &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象 &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 2、编写一个AjaxController 12345678910111213141516171819202122@RestController@RequestMapping(\"/ajax\")public class AjaxController { @GetMapping(\"/1\") public void ajax1(String name , HttpServletResponse response) throws IOException { if (\"admin\".equals(name)){ response.getWriter().print(\"true\"); }else{ response.getWriter().print(\"false\"); } } @PostMapping(\"/1\") public void ajax2(String name , HttpServletResponse response) throws IOException { if (\"admin\".equals(name)){ response.getWriter().print(\"true\"); }else{ response.getWriter().print(\"false\"); } }} 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 12&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;${pageContext.request.contextPath}/statics/js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; 4、编写index.jsp测试 123456789101112131415161718192021222324252627282930313233&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt;--%&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ $.get({ url:\"${pageContext.request.contextPath}/ajax/1?name=\"+$(\"#txtName1\").val(), success:function (data,status) { console.log(data,status); } }); } function a2(){ $.post({ url:\"${pageContext.request.contextPath}/ajax/1\", data:{'name':$(\"#txtName2\").val()}, success:function (data,status) { console.log(data,status); } }); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;label for=\"txtName1\"&gt;get：&lt;/label&gt;&lt;input type=\"text\" id=\"txtName1\" onblur=\"a1()\"/&gt;&lt;br/&gt;用户名:&lt;label for=\"txtName2\"&gt;post：&lt;/label&gt;&lt;input type=\"text\" id=\"txtName2\" onblur=\"a2()\"/&gt;&lt;/body&gt;&lt;/html&gt; 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ Springmvc实现我们来获取一个集合对象，展示到前端页面 12345678@PostMapping(\"/2\") public List&lt;User&gt; ajax2(){ List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(\"秦疆1号\",3,\"男\")); list.add(new User(\"秦疆2号\",3,\"男\")); list.add(new User(\"秦疆3号\",3,\"男\")); return list; //由于@RestController注解，将list转成json格式返回 } 前端页面 1234567891011121314151617181920212223242526272829&lt;input type=\"button\" id=\"btn\" value=\"获取数据\"/&gt;&lt;table width=\"80%\" align=\"center\"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;script&gt; $(function () { $(\"#btn\").click(function () { $.post(\"${pageContext.request.contextPath}/a2\",function (data) { console.log(data) var html=\"\"; for (var i = 0; i &lt;data.length ; i++) { html+= \"&lt;tr&gt;\" + \"&lt;td&gt;\" + data[i].name + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].age + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].sex + \"&lt;/td&gt;\" + \"&lt;/tr&gt;\" } $(\"#content\").html(html); }); }) })&lt;/script&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 注册提示效果我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller 12345678910111213141516171819@PostMapping(\"/3\")public String ajax3(String name,String pwd){ String msg = \"\"; if (name!=null){ if (\"admin\".equals(name)){ msg = \"OK\"; }else { msg = \"用户不存在\"; } } if (pwd!=null){ if (\"123\".equals(pwd)){ msg = \"OK\"; }else { msg = \"密码输入有误\"; } } return msg;} 前端页面 login.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ let uInfo=$(\"#userInfo\") $.post({ url:\"${pageContext.request.contextPath}/ajax/3\", data:{'name':$(\"#name\").val()}, success:function (data) { if (data.toString()==='OK'){ uInfo.css(\"color\",\"green\"); }else { uInfo.css(\"color\",\"red\"); } uInfo.html(data); } }); } function a2(){ let pInfo=$(\"#pwdInfo\") $.post({ url:\"${pageContext.request.contextPath}/ajax/3\", data:{'pwd':$(\"#pwd\").val()}, success:function (data) { if (data.toString()==='OK'){ pInfo.css(\"color\",\"green\"); }else { pInfo.css(\"color\",\"red\"); } pInfo.html(data); } }); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; &lt;label for=\"name\"&gt;用户名:&lt;/label&gt;&lt;input type=\"text\" id=\"name\" onblur=\"a1()\"/&gt; &lt;span id=\"userInfo\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;label for=\"pwd\"&gt;密码:&lt;/label&gt;&lt;input type=\"text\" id=\"pwd\" onblur=\"a2()\"/&gt; &lt;span id=\"pwdInfo\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 拦截器SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器那如何实现拦截器呢？ 想要自定义拦截器，必须实现 HandlerInterceptor 接口。 1、配置web.xml 和 springmvc-servlet.xml 文件 2、编写一个拦截器 12345678910111213141516171819202122232425public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器和被拦截的方法 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\"------------处理前------------\"); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(\"------------处理后------------\"); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\"------------清理------------\"); }} 4、在springmvc的配置文件中配置拦截器 12345678910&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=\"com.kuang.interceptor.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 5、编写一个Controller 6、前端请求 1&lt;a href=&quot;${pageContext.request.contextPath}/interceptor&quot;&gt;拦截器测试&lt;/a&gt; 7、启动tomcat 测试一下！ 验证用户是否登录实现思路 1、有一个登陆页面，需要写一个controller访问页面。 2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 测试： 1、编写一个登陆页面 login.jsp 12345678910111213141516171819&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;h1&gt;登录页面&lt;/h1&gt;&lt;hr&gt;&lt;body&gt;&lt;form action=\"${pageContext.request.contextPath}/user/login\" method=\"post\"&gt; &lt;label&gt; 用户：&lt;input type=\"text\" name=\"username\"&gt; &lt;/label&gt;&lt;br&gt; &lt;label&gt; 密码：&lt;input type=\"password\" name=\"pwd\"&gt; &lt;/label&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2、编写一个Controller处理请求 1234567891011121314151617181920212223242526272829@Controller@RequestMapping(\"/user\")public class UserController { //跳转到登陆页面 @RequestMapping(\"/toLogin\") public String toLogin(HttpSession session) throws Exception { if(session.getAttribute(\"user\")!=null) return \"success\"; else return \"login\"; } //登陆提交 @PostMapping(\"/login\") public String login(HttpSession session, String username, String pwd) throws Exception { // 向session记录用户身份信息 System.out.println(\"接收前端===\" + username); session.setAttribute(\"user\", username); return \"success\"; } //退出登陆 @GetMapping(\"logout\") public String logout(HttpSession session) throws Exception { // session 过期 session.invalidate(); return \"login\"; }} 3、编写一个登陆成功的页面 success.jsp 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录成功页面&lt;/h1&gt;&lt;hr&gt;${sessionScope.get(\"user\")}&lt;a href=\"${pageContext.request.contextPath}/user/logout\"&gt;注销&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！ 1&lt;a href=&quot;${pageContext.request.contextPath}/user/toLogin&quot;&gt;登录&lt;/a&gt; 5、编写用户登录拦截器 123456789101112131415161718192021public class LoginInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { // 如果是登陆页面则放行 System.out.println(\"uri: \" + request.getRequestURI()); if (request.getRequestURI().contains(\"login\")) { System.out.println(\"前往登录页面\"); return true; } HttpSession session = request.getSession(); // 如果用户已登陆也放行 if (session.getAttribute(\"user\") != null) { System.out.println(\"用户已登录\"); return true; } // 用户没有登陆跳转到登陆页面 request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request, response); return false; }} 6、在Springmvc的配置文件中注册拦截器 1234567&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;bean id=\"loginInterceptor\" class=\"com.atomsk.interceptor.LoginInterceptor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 7、再次重启Tomcat测试！ OK，测试登录拦截功能无误. 整合SSM 数据库环境 创建一个存放书籍数据的数据库表 123456789101112131415161718CREATE DATABASE `ssmbuild`;USE `ssmbuild`;DROP TABLE IF EXISTS `books`;CREATE TABLE `books` (`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',`bookName` VARCHAR(100) NOT NULL COMMENT '书名',`bookCounts` INT(11) NOT NULL COMMENT '数量',`detail` VARCHAR(200) NOT NULL COMMENT '描述',KEY `bookID` (`bookID`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,'Java',1,'从入门到放弃'),(2,'MySQL',10,'从删库到跑路'),(3,'Linux',5,'从进门到进牢'); 基本环境搭建1、新建一Maven项目！ssmbuild ， 添加web的支持 2、导入相关的pom依赖！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、Maven资源过滤设置 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 4、建立基本结构和配置框架！ com.kuang.pojo com.kuang.dao com.kuang.service com.kuang.controller mybatis-config.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; applicationContext.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; Mybatis层编写1、数据库配置文件 database.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=123456 2、IDEA关联数据库 3、编写MyBatis的核心配置文件 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/BookMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4、编写数据库对应的实体类 com.kuang.pojo.Books 使用lombok插件！ 1234567891011121314151617package com.kuang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Books { private int bookID; private String bookName; private int bookCounts; private String detail; } 5、编写Dao层的 Mapper接口！ 1234567891011121314151617181920212223package com.kuang.dao;import com.kuang.pojo.Books;import java.util.List;public interface BookMapper { //增加一个Book int addBook(Books book); //根据id删除一个Book int deleteBookById(int id); //更新Book int updateBook(Books books); //根据id查询,返回一个Book Books queryBookById(int id); //查询全部Book,返回list集合 List&lt;Books&gt; queryAllBook();} 6、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包； 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.dao.BookMapper&quot;&gt; &lt;!--增加一个Book--&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt; insert into ssmbuild.books(bookName,bookCounts,detail) values (#{bookName}, #{bookCounts}, #{detail}) &lt;/insert&gt; &lt;!--根据id删除一个Book--&gt; &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt; delete from ssmbuild.books where bookID=#{bookID} &lt;/delete&gt; &lt;!--更新Book--&gt; &lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt; update ssmbuild.books set bookName = #{bookName},bookCounts = #{bookCounts},detail = #{detail} where bookID = #{bookID} &lt;/update&gt; &lt;!--根据id查询,返回一个Book--&gt; &lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where bookID = #{bookID} &lt;/select&gt; &lt;!--查询全部Book--&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt; SELECT * from ssmbuild.books &lt;/select&gt;&lt;/mapper&gt; 7、编写Service层的接口和实现类 接口： 12345678910111213141516171819package com.kuang.service;import com.kuang.pojo.Books;import java.util.List;//BookService:底下需要去实现,调用dao层public interface BookService { //增加一个Book int addBook(Books book); //根据id删除一个Book int deleteBookById(int id); //更新Book int updateBook(Books books); //根据id查询,返回一个Book Books queryBookById(int id); //查询全部Book,返回list集合 List&lt;Books&gt; queryAllBook();} 实现类： 1234567891011121314151617181920212223242526272829303132333435package com.kuang.service;import com.kuang.dao.BookMapper;import com.kuang.pojo.Books;import java.util.List;public class BookServiceImpl implements BookService { //调用dao层的操作，设置一个set接口，方便Spring管理 private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } public int addBook(Books book) { return bookMapper.addBook(book); } public int deleteBookById(int id) { return bookMapper.deleteBookById(id); } public int updateBook(Books books) { return bookMapper.updateBook(books); } public Books queryBookById(int id) { return bookMapper.queryBookById(id); } public List&lt;Books&gt; queryAllBook() { return bookMapper.queryAllBook(); }} OK，到此，底层需求操作编写完毕！ Spring层1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池； 2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.kuang.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、Spring整合service层 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描service相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.kuang.service&quot; /&gt; &lt;!--BookServiceImpl注入到IOC容器中--&gt; &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！ SpringMVC层1、web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; 2、spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot; /&gt;&lt;/beans&gt; 3、Spring配置整合文件，applicationContext.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;import resource=&quot;spring-service.xml&quot;/&gt; &lt;import resource=&quot;spring-mvc.xml&quot;/&gt; &lt;/beans&gt; 配置文件，暂时结束！Controller 和 视图层编写 1、BookController 类编写 ， 方法一：查询全部书籍 123456789101112131415@Controller@RequestMapping(&quot;/book&quot;)public class BookController { @Autowired @Qualifier(&quot;BookServiceImpl&quot;) private BookService bookService; @RequestMapping(&quot;/allBook&quot;) public String list(Model model) { List&lt;Books&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, list); return &quot;allBook&quot;; }} 2、编写首页 index.jsp 1234567891011121314151617181920212223242526272829&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; a { text-decoration: none; color: black; font-size: 18px; } h3 { width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 4px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt; &lt;a href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 3、书籍列表页面 allbook.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;书籍列表&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 column&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/toAddBook&quot;&gt;新增&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;table class=&quot;table table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名字&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach var=&quot;book&quot; items=&quot;${requestScope.get('list')}&quot;&gt; &lt;tr&gt; &lt;td&gt;${book.getBookID()}&lt;/td&gt; &lt;td&gt;${book.getBookName()}&lt;/td&gt; &lt;td&gt;${book.getBookCounts()}&lt;/td&gt; &lt;td&gt;${book.getDetail()}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;${pageContext.request.contextPath}/book/toUpdateBook?id=${book.getBookID()}&quot;&gt;更改&lt;/a&gt; | &lt;a href=&quot;${pageContext.request.contextPath}/book/del/${book.getBookID()}&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 4、BookController 类编写 ， 方法二：添加书籍 1234567891011@RequestMapping(&quot;/toAddBook&quot;)public String toAddPaper() { return &quot;addBook&quot;;}@RequestMapping(&quot;/addBook&quot;)public String addPaper(Books books) { System.out.println(books); bookService.addBook(books); return &quot;redirect:/book/allBook&quot;;} 5、添加书籍页面：addBook.jsp 123456789101112131415161718192021222324252627282930&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;新增书籍&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;新增书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=&quot;${pageContext.request.contextPath}/book/addBook&quot; method=&quot;post&quot;&gt; 书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;/form&gt;&lt;/div&gt; 6、BookController 类编写 ， 方法三：修改书籍 12345678910111213141516@RequestMapping(&quot;/toUpdateBook&quot;)public String toUpdateBook(Model model, int id) { Books books = bookService.queryBookById(id); System.out.println(books); model.addAttribute(&quot;book&quot;,books ); return &quot;updateBook&quot;;}@RequestMapping(&quot;/updateBook&quot;)public String updateBook(Model model, Books book) { System.out.println(book); bookService.updateBook(book); Books books = bookService.queryBookById(book.getBookID()); model.addAttribute(&quot;books&quot;, books); return &quot;redirect:/book/allBook&quot;;} 7、修改书籍页面 updateBook.jsp 12345678910111213141516171819202122232425262728293031&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;修改信息&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;修改信息&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=&quot;${pageContext.request.contextPath}/book/updateBook&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;bookID&quot; value=&quot;${book.getBookID()}&quot;/&gt; 书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; value=&quot;${book.getBookName()}&quot;/&gt; 书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; value=&quot;${book.getBookCounts()}&quot;/&gt; 书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;${book.getDetail() }&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/div&gt; 8、BookController 类编写 ， 方法四：删除书籍 12345@RequestMapping(&quot;/del/{bookId}&quot;)public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) { bookService.deleteBookById(id); return &quot;redirect:/book/allBook&quot;;} 配置Tomcat，进行运行！ 到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！","link":"/blog/2020/07/31/spring-mvc/"}],"tags":[{"name":"数据库","slug":"数据库","link":"/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/blog/tags/SpringBoot/"},{"name":"Swagger2","slug":"Swagger2","link":"/blog/tags/Swagger2/"},{"name":"Spring Security","slug":"Spring-Security","link":"/blog/tags/Spring-Security/"},{"name":"Oauth2","slug":"Oauth2","link":"/blog/tags/Oauth2/"},{"name":"设计模式","slug":"设计模式","link":"/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"AOP","slug":"AOP","link":"/blog/tags/AOP/"},{"name":"Docker","slug":"Docker","link":"/blog/tags/Docker/"},{"name":"MySQL","slug":"MySQL","link":"/blog/tags/MySQL/"},{"name":"MyBatis","slug":"MyBatis","link":"/blog/tags/MyBatis/"},{"name":"mybatis-plus","slug":"mybatis-plus","link":"/blog/tags/mybatis-plus/"},{"name":"前端","slug":"前端","link":"/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"HTTP","slug":"HTTP","link":"/blog/tags/HTTP/"},{"name":"Vue","slug":"Vue","link":"/blog/tags/Vue/"},{"name":"Spirng","slug":"Spirng","link":"/blog/tags/Spirng/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/blog/tags/SpringMVC/"}],"categories":[{"name":"配置","slug":"配置","link":"/blog/categories/%E9%85%8D%E7%BD%AE/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/blog/categories/SpringBoot/"},{"name":"安全","slug":"安全","link":"/blog/categories/%E5%AE%89%E5%85%A8/"},{"name":"设计模式","slug":"设计模式","link":"/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","link":"/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"运维","slug":"运维","link":"/blog/categories/%E8%BF%90%E7%BB%B4/"},{"name":"数据库","slug":"数据库","link":"/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBatis","slug":"MyBatis","link":"/blog/categories/MyBatis/"},{"name":"创建型模式","slug":"设计模式/创建型模式","link":"/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"MySQL","slug":"数据库/MySQL","link":"/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"前端","slug":"前端","link":"/blog/categories/%E5%89%8D%E7%AB%AF/"},{"name":"框架","slug":"前端/框架","link":"/blog/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","link":"/blog/categories/Spring/"}]}