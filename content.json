{"pages":[],"posts":[{"title":"DBCP2配置参数详解、","text":"常用链接配置 参数 描述 username 传递给JDBC驱动的用于建立连接的用户名 password 传递给JDBC驱动的用于建立连接的密码 url 传递给JDBC驱动的用于建立连接的URL driverClassName 使用的JDBC驱动的完整有效的java 类名 connectionProperties 当建立新连接时被发送给JDBC驱动的连接参数，格式必须是 [propertyName=property;]。 注意：参数user/password将被明确传递，所以不需要包括在这里。 数据源连接数量配置 参数 默认值 描述 initialSize 0 初始化连接:连接池启动时创建的初始化连接数量,1.2版本后支持 maxActive 8 最大活动连接:连接池在同一时间能够分配的最大活动连接的数量, 如果设置为非正数则表示不限制 maxIdle 8 最大空闲连接:连接池中容许保持空闲状态的最大连接数量,超过的空闲连接将被释放,如果设置为负数表示不限制 minIdle 0 最小空闲连接:连接池中容许保持空闲状态的最小连接数量,低于这个数量将创建新的连接,如果设置为0则不创建 maxWait 无限 最大等待时间:当没有可用连接时,连接池等待连接被归还的最大时间(以毫秒计数),超过时间则抛出异常,如果设置为-1表示无限等待 事务属性配置 参数 默认值 描述 defaultAutoCommit true 连接池创建的连接的默认的auto-commit状态 defaultReadOnly driver default 连接池创建的连接的默认的read-only状态. 如果没有设置则setReadOnly方法将不会被调用.(某些驱动不支持只读模式,比如:Informix) defaultTransactionIsolation driver default 连接池创建的连接的默认的TransactionIsolation状态. 下面列表当中的某一个: (参考javadoc) NONE、READ_COMMITTED、READ_UNCOMMITTED、REPEATABLE_READ、SERIALIZABLE defaultCatalog 连接池创建的连接的默认的catalog 数据源连接健康状况检查 参数 默认值 描述 validationQuery SQL查询,用来验证从连接池取出的连接,在将连接返回给调用者之前.如果指定,则查询必须是一个SQL SELECT并且必须返回至少一行记录 testOnBorrow true 指明是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个. 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 testOnReturn false 指明是否在归还到池中前进行检验. 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 testWhileIdle false 指明连接是否被空闲连接回收器(如果有)进行检验.如果检测失败,则连接将被从池中去除. 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 timeBetweenEvictionRunsMillis -1 在空闲连接回收器线程运行期间休眠的时间值,以毫秒为单位.如果设置为非正数,则不运行空闲连接回收器线程 numTestsPerEvictionRun 3 在每次空闲连接回收器线程(如果有)运行时检查的连接数量 minEvictableIdleTimeMillis 10006030 连接在池中保持空闲而不被空闲连接回收器线程(如果有)回收的最小时间值，单位毫秒 缓存语句 参数 默认值 描述 poolPreparedStatements false 开启池的prepared statement 池功能 maxOpenPreparedStatements 不限制 statement池能够同时分配的打开的statements的最大数量, 如果设置为0表示不限制 连接泄露回收 参数 默认值 描述 removeAbandoned false 标记是否删除泄露的连接,如果他们超过了removeAbandonedTimout的限制.如果设置为true, 连接被认为是被泄露并且可以被删除,如果空闲时间超过removeAbandonedTimeout. 设置为true可以为写法糟糕的没有关闭连接的程序修复数据库连接. removeAbandonedTimeout 300 泄露的连接可以被删除的超时值, 单位秒 logAbandoned false 标记当Statement或连接被泄露时是否打印程序的stack traces日志。被泄露的Statements和连接的日志添加在每个连接打开或者生成新的Statement,因为需要生成stack trace。","link":"/blog/2020/05/20/DBCP2/"},{"title":"Docker进阶","text":"笔记整理来源 B站UP主遇见狂神说 Docker容器数据卷 在Docker容器的实际使用中，经常会遇到容器的数据持久化，容器之间的数据共享等问题，通常我们有两种解决方案： 数据卷（Data Volumes）：就是将容器内数据直接映射到本地主机环境的指定文件目录之中，可以理解为容器挂载一个虚拟数据卷然后 映射到一个主机目录中 数据卷容器（Data Volume Containers）：用专门的容器来挂载数据卷，其他容器通过挂载这个父容器来实现数据共享，这个专门挂载数据卷的容器就是数据卷容器，简单的总结就是有一个容器来专门管理数据的持久化和容器之间数据共享。 使用数据卷 方式一：直接使用命令挂载 -v 指定路径进行挂载 12#指定路径挂载 -v 宿主机路径:容器内路径 docker run --name vhr-data -e MYSQL_ROOT_PASSWORD=123456 -v /home/atomsk/mysql/db:/var/lib/mysql -d -p 3306:3306 mysql 匿名挂载和具名挂载 1234567891011# 匿名挂载 -v 容器内路径$ docker run -d -P --name nginx01 -v /etc/nginx nginx$ docker volume ls # 查看所有的volume的情况DRIVER VOLUME NAMElocal 33ae588fae6d34f511a769948f0d3d123c9d45c442ac7728cb85599c2657e50d # 具名挂载 -v 卷名:容器内路径$ docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx$ docker volume ls DRIVER VOLUME NAMElocal juming-nginx 也可以通过docker volume inspect 卷名查看卷的情况 注意：所有的Docker容器内的卷，在没有指定目录的情况下都是在/var/lib/docker/volumes/xxxx/_data路径下的 拓展：容器对宿主机文件的操作权限 1234567# 通过 -v 容器内路径： ro rw 改变读写权限ro #readonly 只读rw #readwrite 可读可写$ docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx$ docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！ 方式二：通过Dockerfile添加 注意：出于可移植可分享的的考虑，用以上 -v /宿主机绝对路径目录 : /容器内目录 的这种方式不能够直接在DockerFile中直接实现，因为宿主机目录是依赖于特定的宿主机的，并不能保证所有的宿主机都存在这样特定的目录 假设编写的DockerFile如下 1234567FROM 镜像名VOLUME [\"/容器内路径\"]CMD echo \"success build\"CMD /bin/bash 指令VOLUME [&quot;/生成的目录路径&quot;]就相当于docker run -it -v /容器内路径，即匿名挂载 使用数据卷容器1234$ docker run -it - -name parentContainer 镜像名$ docker run -it - -name sonContainer1 --volumes -from parentContainer 镜像名$ docker run -it - -name sonContainer2 --volumes -from parentContainer 镜像名 官网上有一句话描述的是，容器之间配置信息的传递，数据卷的生命周期会一致持续到没有容器使用它为止，换言之，只要有一个容器仍在使用该数据卷，该数据卷一直都可以进行数据共享。 通俗地来说，如果此时我们把父容器关闭掉，两个字容器之间依旧可以进行数据共享，而且通过继承子容器生成的新容器，一样可以与子容器进行数据共享。这就是docker容器间的数据传递共享。 DockerfileDockerfile 就是用来构建docker镜像的构建文件，是一个命令参数脚本。 构建步骤 编写一个Dockerfile文件 docker build -f Dockerfile名 -t 命名空间/镜像名:[tag] 构建出一个镜像 docker run 运行镜像（测试） docker push 发布镜像（DockerHub 、阿里云仓库) Dockerfile的编写基础知识： 每个保留关键字都是必须是大写字母 从上到下顺序执行，#表示注释 每一个指令都会创建一个新的镜像层 Dockerfile指令： 123456789101112FROM # 基础镜像，一切从这里开始构建MAINTAINER # 镜像是谁写的， 姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 格式举例：ADD tomcat.tar.gz /usr/local/，会自动解压WORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 保留端口配置CMD # 指定这个容器启动的时候默认运行的命令，当指定其他命令时会被替换。ls -a 指定-l =》 -l 报错ENTRYPOINT # 指定这个容器启动的时候默认运行的命令，可以在其基础上追加命令 ls -a，追加-l =》 ls -alONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。COPY # 类似ADD，直接将文件拷贝到镜像中ENV # 构建的时候设置环境变量！ ✅可以通过docker history 镜像id查看镜像的构建过程 实战：Tomcat镜像构建 准备镜像文件 准备tomcat 和 jdk到当前目录，编写好README 编写Dokerfile 12345678910111213FROM centos #MAINTAINER Atomsk&lt;Atomsk@126.com&gt;COPY README /usr/local/README #复制文件ADD jdk-8u231-linux-x64.tar.gz /usr/local/ #复制解压ADD apache-tomcat-9.0.35.tar.gz /usr/local/ #复制解压RUN yum -y install vimENV MYPATH /usr/local #设置环境变量WORKDIR $MYPATH #设置工作目录ENV JAVA_HOME /usr/local/jdk1.8.0_231 #设置环境变量ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.35 #设置环境变量ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib #设置环境变量 分隔符是：EXPOSE 8080 #设置暴露的端口CMD /usr/local/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.35/logs/catalina.out # 设置默认命令 构建镜像 12# 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件$ docker build -t mytomcat:0.1 . run镜像 1$ docker run -d -p 8080:8080 --name tomcat01 -v /home/atomsk/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test -v /home/atomsk/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs mytomcat:0.1 访问测试 发布项目(由于做了卷挂载，我们直接在本地编写项目就可以发布了！) 发布镜像发布到Dockerhub： 注册，地址 https://hub.docker.com/ 登录 12$ docker login -u 用户名#回车然后输入密码 提交 push镜像 12345# push不上去的解决方法# 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了$ docker build -t atomsk/mytomcat:0.1 .# 第二种 使用docker tag #然后再次push$ docker tag 容器id atomsk/mytomcat:1.0 #然后再次push 发布到阿里云镜像服务器： ​ 详见官网：https://cr.console.aliyun.com/repository/ 小结","link":"/blog/2020/06/28/Docker-advanced/"},{"title":"Docker基础","text":"笔记整理来源 B站UP主遇见狂神说 Docker基本概念Docker是一个使用容器开发、部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。 容器化越来越受欢迎，是因为容器有以下特点： 灵活性：即使是最复杂的应用程序也可以被容器化 轻量级：容器利用并共享主机内核 可互换的：你可以实时部署更新和升级 可移植性：你可以在本地构建、部署到云，并在任何地方运行 可伸缩：你可以增加并自动分发容器副本 可叠加：你可以垂直地、动态地叠加服务 Docker的基本组成 镜像（image)：一个镜像是一个可执行包，它包含运行应用程序所需的所有内容，包括代码、运行时环境、库、环境变量、配置文件。 容器(container)：容器是镜像的运行时实例。可以把一个容器理解成一个简易的 Linux系统。 仓库(repository)：仓库就是存放镜像的地方，Docker Hub是国外的，所以要下载镜像前要配置阿里云镜像加速器。 容器和虚拟机对比 Docker安装帮助文档：https://docs.docker.com/engine/install/ 12345678910111213141516171819202122#1.卸载旧版本$ yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine#2.Install the yum-utils package (which provides the yum-config-manager utility) and set up the stable repository.$ yum install -y yum-utils$ yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #此处用阿里云的仓库#更新yum软件包索引$ yum makecache fast#3.安装docker相关的 docker-ce 社区版 而ee是企业版$ yum install docker-ce docker-ce-cli containerd.io#4. 使用docker version查看是否按照成功$ docker version#5. 测试$ docker run hello-world 安装完成后配置阿里云镜像加速器 Docker常用命令帮助文档：https://docs.docker.com/reference/ 镜像命令使用docker image查看所有镜像相关命令 123docker images #查看所有本地主机上的镜像docker pull IMAGE[:TAG] #下载镜像docker rmi IMAGE #删除镜像 容器命令使用docker containter查看所有容器相关明命令 123docker ps #列出所有运行中的容器docker run 镜像id #新建容器并启动docker rm 容器id #删除指定容器 常用的镜像创建示例 12345678910111213mysql：docker run --name vhr-data -e MYSQL_ROOT_PASSWORD=123456 -v /home/atomsk/mysql/db:/var/lib/mysql -d -p 3306:3306 mysqlredis：docker run --name vhr-redis -d -p 6379:6379 redisrabbitmq：docker run --name vhr-rabbitmq -d -p 5672:5672 -p 15672:15672 rabbitmqnginx：docker run --name vhr-nginx -v /home/atomsk/vhr/vuehr:/usr/share/nginx/html -v /home/atomsk/vhr/nginx/nginx.conf:/etc/nginx/nginx.conf -d -p 8085:80 nginx或者docker run --name vhr-nginx -v /home/atomsk/vhr/vuehr:/usr/share/nginx/html -v /home/atomsk/vhr/nginx/default.conf:/etc/nginx/conf.d/default.conf -d -p 8085:80 nginx 启动和停止容器的操作 1234docker start 容器id #启动容器docker restart 容器id #重启容器docker stop 容器id #停止当前正在运行的容器docker kill 容器id #强制停止当前容器 其他常用命令123docker logs 容器id #查看日志docker inspect 镜像id/容器id #查看镜像/容器的元数据docker exec -it 容器id /bin/bash #进入容器 命令图解 Docker镜像详解镜像是什么镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时环境、库、环境变量和配置文件。 如何得到镜像： 从远程仓库下载 通过DockerFile自制一个镜像 镜像加载原理 UnionFS（联合文件系统） UnionFS是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 Docker镜像加载原理 Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFS。 boots(boot file system）主要包含 bootloader和 Kernel。 bootloader主要是引导加 kernel，Linux刚启动时会加载bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。 rootfs（root file system)，在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host（宿主机）的kernel，自己只需要提供rootfs就行了，由此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。 对分层的理解 思考：为什么Docker镜像要采用这种分层的结构呢？ 最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像；同时内存中也只需要加载一份base镜像，就可以为所有的容器服务了，而且镜像的每一层都可以被共享。 可以通过 docker inspect 镜像id 命令查看镜像元数据，看到镜像的具体分层信息 12345678910111213...\"RootFS\": { \"Type\": \"layers\", \"Layers\": [ \"sha256:c2adabaecedbda0af72b153c6499a0555f3a769d52370469d8f6bd6328af9b13\", \"sha256:744315296a49be711c312dfa1b3a80516116f78c437367ff0bc678da1123e990\", \"sha256:379ef5d5cb402a5538413d7285b21aa58a560882d15f1f553f7868dc4b66afa8\", \"sha256:d00fd460effb7b066760f97447c071492d471c5176d05b8af1751806a1f905f8\", \"sha256:4d0c196331523cfed7bf5bafd616ecb3855256838d850b6f3d5fba911f6c4123\", \"sha256:98b4a6242af2536383425ba2d6de033a510e049d9ca07ff501b95052da76e894\" ] },... Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统 Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。 分层特点 当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 容器层的细节说明镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。 文件操作 说明 添加文件 在容器中创建文件时，新文件被添加到容器层中。 读取文件 在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。 修改文件 在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。 删除文件 在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。（比如增加一个对应的Whiteout文件） 只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。 通过commit指令生成镜像12345678# 1、启动一个默认的tomcat$ docker run -d -p 8080:8080 tomcat# 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！$ docker exec -it 容器id# 3、拷贝文件进去# 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。# docker commit -m=\"描述信息\" -a=\"作者\" 容器id 目标镜像名:[TAG]$ docker commit -a=\"atomsk\" -m=\"add webapps app\" 容器id mytomcat:1.0 如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。","link":"/blog/2020/06/26/Docker-base/"},{"title":"MySQL高级","text":"笔记整理来源 黑马程序员MySQL教程 索引索引概述定义：索引是帮助MySQL高效获取数据的数据结构（有序）。 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。 索引的优劣势优势： 提高数据检索的效率，降低数据库的IO成本。 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。 劣势： 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件，每次更新了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。 索引结构索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。 索引 InnoDB引擎 MyISAM引擎 Memory引擎 BTREE索引 支持 支持 支持 HASH 索引 不支持 不支持 支持 Full-text 5.6版本之后支持 支持 不支持 我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。 BTREE结构BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下： 树中每个节点最多包含m个孩子。 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。 若根节点不是叶子节点，则至少有两个孩子。 所有的叶子节点都在同一层。 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1 以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。 插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。 演变过程如下： 1). 插入前4个字母 C N G A 2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点 3). 插入E，K，Q不需要分裂 4). 插入M，中间元素M字母向上分裂到父节点G 5). 插入F，W，L，T不需要分裂 6). 插入Z，中间元素T向上分裂到父节点中 7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂 8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂 到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。 B+TREE 结构B+Tree为BTree的变种，B+Tree与BTree的区别为： 1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。 2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。 3). 所有的非叶子节点都可以看作是key的索引部分。 由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。 MySQL中的B+TreeMySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。 MySQL中的 B+Tree 索引结构示意图: 索引分类 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引 唯一索引 ：索引列的值必须唯一，但允许有空值 复合索引 ：即一个索引包含多个列 索引语法创建索引、删除索引、查看索引语法： 12345678910CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type]ON tbl_name(index_col_name,...)index_col_name : column_name[(length)][ASC | DESC]#删除索引DROP INDEX index_name ON tbl_name;#查看索引,可选参数：\\GSHOW INDEX FROM table_name\\G; ALTER命令1234567891011121314151). alter table tb_name add primary key(column_list); 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL 2). alter table tb_name add unique index_name(column_list); 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次） 3). alter table tb_name add index index_name(column_list); 添加普通索引， 索引值可以出现多次。 4). alter table tb_name add fulltext index_name(column_list); 该语句指定了索引为FULLTEXT， 用于全文索引 设计原则索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。 12345678创建复合索引: CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ; 视图视图概述​ 视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 视图相对于普通的表的优势主要包括以下几项。 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 视图使用创建视图： 1234567CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 修改视图： 12345678910111213ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION]选项 : WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。 LOCAL ： 只要满足本视图的条件就可以更新。 CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值. 删除视图： 1DROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADE] 查看视图： 从 MySQL 5.1 版本开始，使用SHOW TABLES命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令，SHOW TABLE STATUS命令同理 如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW命令进行查看 ： 存储过程存储过程和函数概述​ 存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 ​ 存储过程和函数的区别在于函数必须有返回值，而存储过程没有。 存储过程使用创建： 1234CREATE PROCEDURE procedure_name ([proc_parameter[,...]])BEGIN -- SQL语句END ; 调用： 1CALL procedure_name() ; 删除： 1DROP PROCEDURE [IF EXISTS] sp_name ; 查看： 12345678-- 查询db_name数据库中的所有的存储过程select name from mysql.proc where db='db_name';-- 查询存储过程的状态信息show procedure status;-- 查询某个存储过程的定义show create procedure test.pro_test01 \\G; 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 变量 DECLARE 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 1DECLARE var_name[,...] type [DEFAULT value] SET 直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： 1SET var_name = expr [, var_name = expr] ... 示例 : 123456789101112DELIMITER $CREATE PROCEDURE pro_test1()BEGIN DECLARE NAME VARCHAR(20);#声明一个varchar型的变量name SET NAME = 'MYSQL'; #也可以使用select ... into进行赋值操作 SELECT 'MYSQL' INTO NAME; SELECT NAME ;END$DELIMITER ; 条件判断IF 语法结构 : 1234567if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; CASE 语法结构 : 123456789101112131415161718192021方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE;方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 参数传递语法格式 : 1234567create procedure procedure_name([in/out/inout] 参数名 参数类型)...IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认OUT: 该参数作为输出，也就是该参数可以作为返回值INOUT: 既可以作为输入参数，也可以作为输出参数 示例: 12345678910create procedure pro_test5(in height int , out description varchar(100))begin if height &gt;= 180 then set description='身材高挑'; elseif height &gt;= 170 and height &lt; 180 then set description='标准身材'; else set description='一般身材'; end if;end$ 调用: 123call pro_test5(168, @description)$select @description$ 小知识 @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 @@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 while循环语法结构: 12345while search_condition do statement_list end while; repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 语法结构 : 1234567REPEAT statement_list UNTIL search_conditionEND REPEAT; loop和leaveLOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下： 12345[begin_label:] LOOP statement_listEND LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 LEAVE 用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： 1234567891011121314151617CREATE PROCEDURE pro_test(in n int)BEGIN declare total int default 0; abc: LOOP IF n &lt;= 0 then leave ins; END IF; set total = total + n; set n = n - 1; END LOOP abc; select total;END 游标/光标（略）存储函数语法结构: 12345CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ...END; 案例 : 定义一个存储过程, 请求满足条件的总记录数 ; 123456789create function count_city(countryId int)returns intbegin declare cnum int ; select count(*) into cnum from city where country_id = countryId; return cnum;end 调用: 12select count_city(1);select count_city(12); 触发器介绍触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 创建触发器语法结构 : 12345678910111213create trigger trigger_name before/after insert/update/deleteon tbl_name [ for each row ] -- 行级触发器begin trigger_stmt ;end; 使用示例 需求：通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除； 首先创建一张日志表 : 12345678create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment '操作类型, insert/update/delete', operate_time datetime not null comment '操作时间', operate_id int(11) not null comment '操作表的ID', operate_params varchar(500) comment '操作参数', primary key(`id`))engine=innodb default charset=utf8; 创建 insert 型触发器，完成插入数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_insert_triggerafter insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'insert',now(),new.id,concat('插入后(id:',new.id,', name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $DELIMITER ; 创建 update 型触发器，完成更新数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_update_triggerafter update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'update',now(),new.id,concat('修改前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,') , 修改后(id',new.id, 'name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $DELIMITER ; 创建delete 行的触发器 , 完成删除数据时的日志记录 : 1234567891011DELIMITER $create trigger emp_logs_delete_triggerafter delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'delete',now(),old.id,concat('删除前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,')')); end $DELIMITER ; 测试： 123456insert into emp(id,name,age,salary) values(null, '光明左使',30,3500);insert into emp(id,name,age,salary) values(null, '光明右使',33,3200);update emp set age = 39 where id = 3;delete from emp where id = 5; 删除触发器语法结构 : 1drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 语法结构 ： 1show triggers ;","link":"/blog/2020/07/02/MySQL-advanced/"},{"title":"SpringBoot整合Swagger2","text":"第一步：加入相关依赖1234567891011121314&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 第二步：创建Swagger2配置1234567891011121314151617181920@Configuration@EnableSwagger2public class Swagger2Config { @Bean Docket docket(){ return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.basePackage(\"com.atomsk.swagger2.controller\")) .paths(PathSelectors.any()) .build().apiInfo(new ApiInfoBuilder() .description(\"接口文档的描述信息\") .title(\"xxx项目接口文档\") .contact(new Contact(\"atomsk\", \"https://atomskgit.github.io/blog/\", \"atomsk@126.com\")) .version(\"v1.0\") .license(\"Apache2.0\") .build()); }} 配置完成后就可以开启项目在http://localhost:8080/swagger-ui.html里看到效果了。 第三步：给模块和接口加上注释模块相关注释123456789@ApiModel(value = \"用户实体类\",description = \"用于登录网站\")public class User { @ApiModelProperty(value = \"用户id\") private Integer id; @ApiModelProperty(value = \"用户名\") private String username; @ApiModelProperty(value = \"用户密码\") private String password; } 效果如图: 接口相关注释12345678910111213141516171819202122@Api(tags = \"用户管理相关接口\")//@Api 注解可以用来标记当前 Controller 的功能。@RestController@RequestMapping(\"/user\")public class UserController { @ApiOperation(value = \"更新用户\", notes = \"根据用户id更新用户名\") @ApiImplicitParams({ @ApiImplicitParam(name = \"id\", value = \"用户id\", required = true), @ApiImplicitParam(name = \"username\", value = \"用户名\", required = true, defaultValue = \"atomsk\") }) @ApiResponses({ @ApiResponse(code = 200, message = \"更新成功\"), @ApiResponse(code = 500, message = \"更新失败\") }) @PutMapping(\"/user\") public User updateUsernameById(String username, Integer id) { User user = new User(); user.setId(id); user.setUsername(username); return user; }} 效果如图： 注意如果配置了Spring Security，记得做以下配置防止Swagger2文件被拦截 1234567@Overridepublic void configure(WebSecurity web) throws Exception { web.ignoring() .antMatchers(\"/swagger-ui.html\") .antMatchers(\"/v2/**\") .antMatchers(\"/swagger-resources/**\");}","link":"/blog/2020/05/27/SpringBoot-Swagger2/"},{"title":"MySQL高级——索引使用和SQL优化","text":"Mysql的体系结构概览 整个MySQL Server由以下组成 Connection Pool : 连接池组件 Management Services &amp; Utilities : 管理服务和工具组件 SQL Interface : SQL接口组件 Parser : 查询分析器组件 Optimizer : 优化器组件 Caches &amp; Buffers : 缓冲池组件 Pluggable Storage Engines : 存储引擎 File System : 文件系统 1） 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 2） 服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。 3） 引擎层 存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。 4）存储层 数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。 存储引擎存储引擎概述​ 存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。 ​ Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。 ​ MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。 可以通过指定show engines ， 来查询当前数据库支持的存储引擎 创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。 查看Mysql数据库默认的存储引擎 ， 指令 ： 1show variables like '%storage_engine%' ； 各种存储引擎特性下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： 特点 InnoDB MyISAM MEMORY MERGE NDB 存储限制 64TB 有 有 没有 有 事务安全 支持 锁机制 行锁(适合高并发) 表锁 表锁 表锁 行锁 B树索引 支持 支持 支持 支持 支持 哈希索引 支持 全文索引 支持(5.6版本之后) 支持 集群索引 支持 数据索引 支持 支持 支持 索引缓存 支持 支持 支持 支持 支持 数据可压缩 支持 空间使用 高 低 N/A 低 低 内存使用 高 低 中等 低 高 批量插入速度 低 高 高 高 高 支持外键 支持 下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。 InnoDB​ InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。 InnoDB存储引擎不同于其他存储引擎的特点 ： 1. 事务控制 2. 外键约束 ​ MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。 ​ 下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。 1234567891011121314151617181920create table country_innodb( country_id int NOT NULL AUTO_INCREMENT, country_name varchar(100) NOT NULL, primary key(country_id))ENGINE=InnoDB DEFAULT CHARSET=utf8;create table city_innodb( city_id int NOT NULL AUTO_INCREMENT, city_name varchar(50) NOT NULL, country_id int NOT NULL, primary key(city_id), key idx_fk_country_id(country_id), CONSTRAINT `fk_city_country` FOREIGN KEY(country_id) REFERENCES country_innodb(country_id) ON DELETE RESTRICT ON UPDATE CASCADE)ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into country_innodb values(null,'China'),(null,'America'),(null,'Japan');insert into city_innodb values(null,'Xian',1),(null,'NewYork',2),(null,'BeiJing',1); 在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。 RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新； CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录； SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。 针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。 测试： 删除country_id为1 的country数据： 更新主表country表的字段 country_id : 更新后， 子表的数据信息为 ： 3. 存储方式 InnoDB 存储表和索引有以下两种方式 ： ①. 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。 ②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。 MyISAM​ MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： 1. 不支持事务 2. 文件存储方式 每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： .frm (存储表定义)； .MYD(MYData , 存储数据)； .MYI(MYIndex , 存储索引)； MEMORY​ Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。 MERGE​ MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。 ​ 对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。 ​ 可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。 存储引擎的选择 InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。 MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。 MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。 优化SQL的步骤查看SQL执行频率MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。 参数，session ：当前连接的统计结果，global ：自数据库上次启动至今的统计结果。如果不写，默认使用参数是“session”。 下面的命令显示了当前 session 中所有统计参数的值： 1show status like 'Com_______'; 1show status like 'Innodb_rows_%'; Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。 参数 含义 Com_select 执行 select 操作的次数，一次查询只累加 1。 Com_insert 执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。 Com_update 执行 UPDATE 操作的次数。 Com_delete 执行 DELETE 操作的次数。 Innodb_rows_read select 查询返回的行数。 Innodb_rows_inserted 执行 INSERT 操作插入的行数。 Innodb_rows_updated 执行 UPDATE 操作更新的行数。 Innodb_rows_deleted 执行 DELETE 操作删除的行数。 Connections 试图连接 MySQL 服务器的次数。 Uptime 服务器工作时间。 Slow_queries 慢查询的次数。 Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计。 Innodb_*** : 这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。 定位低效率执行SQL可以通过以下两种方式定位执行效率较低的 SQL 语句。 慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。 show processlist : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。 字段 含义 id 用户登录mysql时，系统分配的”connection_id”，可以使用函数connection_id()查看 user 显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句 host 显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户 db 显示这个进程目前连接的是哪个数据库 command 显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等 time 显示这个状态持续的时间，单位是秒 state 显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成 info 显示这个sql语句，是判断问题语句的一个重要依据 explain分析执行计划通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表的连接方式以及连接的顺序。 查询SQL语句的执行计划 ： 1explain select * from tb_item where id = 1; 字段 含义 id select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。 select_type 表示 SELECT 的连接类型 table 输出结果集的表 type 表示表的访问类型 possible_keys 表示查询时，可能使用的索引 key 实际使用的索引，如果为NULL，则没有使用索引。 key_len 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下,长度越短越好 。 rows 扫描行的数量 extra 执行情况的说明和描述 explain 之 idid 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： id 相同表示加载表的顺序是从上到下。 id 不同id值越大，优先级越高，越先被执行。 id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。 explain 之 select_type 表示 SELECT 的类型，常见的取值，如下表所示： select_type 含义 SIMPLE 简单的select查询，查询中不包含子查询或者UNION PRIMARY 查询中若包含任何复杂的子查询，最外层查询标记为该标识 SUBQUERY 在SELECT 或 WHERE 列表中包含了子查询 DERIVED 在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中 UNION 若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED UNION RESULT 从UNION表获取结果的SELECT explain 之 typetype 显示的是访问类型，是较为重要的一个指标，可取值为： type 含义 NULL MySQL不访问任何表，索引，直接返回结果 system 表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现 const 表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常量。const将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较 eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描 ref 非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行 range 只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。 index index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。 all 将遍历全表以找到匹配的行 结果值从最好到最坏以此是： 1234NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALLsystem &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。 explain 之 extra其他的额外的执行计划信息，在该列展示 。 extra 含义 using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低 using temporary 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低 using index 表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。 using where 在查找使用索引的情况下，需要回表去查询所需的数据 using index condition 查找使用了索引，但是需要回表查询数据 using index ; using where 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 show profile分析SQLMysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。 通过 have_profiling 参数，能够看到当前MySQL是否支持profile： 默认profiling是关闭的，可以通过set语句在Session级别开启profiling： 1set profiling=1; //开启profiling 开关； 通过profile，我们能够更清楚地了解SQL执行的过程。 首先，我们可以执行一系列的操作，如下图所示： 123456789show databases;use db01;show tables;select * from tb_item where id &lt; 5;select count(*) from tb_item; 执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时： 通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间： TIP ：Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。 在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间 ： 字段 含义 Status sql 语句执行的状态 Duration sql 执行过程中每一个步骤的耗时 CPU_user 当前用户占有的cpu CPU_system 系统占有的cpu trace分析优化器执行计划MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。 1）打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。 12SET optimizer_trace=\"enabled=on\",end_markers_in_json=on;set optimizer_trace_max_mem_size=1000000; 2）执行SQL语句 3）检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ： 1select * from information_schema.optimizer_trace\\G; 索引的使用索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。 避免索引失效 全值匹配 ，对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。 最左前缀法则 如果索引了多列，遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列，否则只有左边匹配上的列的索引生效 范围查询右边的列，不参与索引使用 。 根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。 不要在索引列上进行运算操作，否则索引将失效。 字符串不加单引号，会造成索引失效。 原因：在查询时，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。 尽量使用覆盖索引，避免select *，如果查询列超出索引列，也会降低性能。 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。 以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。 解决方案 ： 通过覆盖索引来解决 如果MySQL评估使用索引比全表更慢，则不使用索引。 比如：is NULL 、is NOT NULL 有时索引会失效，当NULL的数据占大多数时，查询is NULL不使用索引 in 走索引， not in 索引失效。 单列索引和复合索引。 尽量使用复合索引，而少使用单列索引 。 创建复合索引 123456create index idx_name_sta_address on tb_seller(name, status, address);就相当于创建了三个索引 ： name name + status name + status + address 创建单列索引如下，使用时数据库只会选择一个最优的索引（辨识度最高索引），并不会使用全部索引 。 123create index idx_seller_name on tb_seller(name);create index idx_seller_status on tb_seller(status);create index idx_seller_address on tb_seller(address); 查看索引使用情况123show status like 'Handler_read%'; show global status like 'Handler_read%'; 字段 含义 Handler_read_first 索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好） Handler_read_key 如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好） Handler_read_next 按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加 Handler_read_prev 按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC Handler_read_rnd 根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救 Handler_read_rnd_next 在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引 SQL优化大批量插入数据当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。 对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率： 1） 主键顺序插入 因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。 2） 关闭唯一性校验 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。 3） 手动提交事务 如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。 优化insert语句当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。 如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。 示例， 原始方式为： 123insert into tb_test values(1,'Tom');insert into tb_test values(2,'Cat');insert into tb_test values(3,'Jerry'); 优化后的方案为 ： 1insert into tb_test values(1,'Tom'),(2,'Cat')，(3,'Jerry'); 在事务中进行数据插入。 数据按主键顺序有序插入。 优化order by语句两种排序方式 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。 优化思路： 了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和order by 使用相同的索引，并且order By 的顺序和索引顺序相同， 并且order by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。 Filesort 的优化通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法： 1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。 2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。 MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。 可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。 优化group by 语句由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。 如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ： 123drop index idx_emp_age_salary on emp;explain select age,count(*) from emp group by age; 优化后 1explain select age,count(*) from emp group by age order by null; 利用索引 ： 1create index idx_emp_age_salary on emp(age,salary)； 优化嵌套查询Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。 示例 ，查找有角色的所有的用户信息 : 1explain select * from t_user where id in (select user_id from user_role ); 执行计划为 : 优化后 : 1explain select * from t_user u , user_role ur where u.id = ur.user_id; 连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。 优化OR条件 增加索引。对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。 使用 union 替换 or 1select * from emp where id = 1 or id = 10 我们来比较下重要指标，发现主要差别是 type 和 ref 这两项 type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： 1system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距 UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快 这两项的差距就说明了 UNION 要优于 OR 。 优化分页查询一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。 优化思路一在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。 优化思路二该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。 使用SQL提示SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 USE INDEX在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。 1select * from tb_seller user index(idx_seller_name) where name = '小米科技'; IGNORE INDEX如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。 1select * from tb_seller ignore index(idx_seller_name) where name = '小米科技'; FORCE INDEX为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 1select * from tb_seller force index(idx_seller_address) where address = '北京市';","link":"/blog/2020/07/04/MySQL-index-use&SQL-optimized/"},{"title":"OAuth2授权码模式Demo","text":"案例架构 项目 端口 备注 auth-server 8080 授权服务器 resource-server 8081 资源服务器 client-app 8082 第三方应用 授权服务器创建SpringBoot应用并加入三个依赖： web spring cloud security spirng cloud OAuth2 1.对Spring Security做一些基本配置： 123456789101112131415161718192021222324@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"atomsk\") .password(new BCryptPasswordEncoder().encode(\"123\")) .roles(\"admin\") .and() .withUser(\"guest\") .password(new BCryptPasswordEncoder().encode(\"123\")) .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable().formLogin(); }} 2.用Redis存储token 12345678910@Configurationpublic class AccessTokenConfig { @Autowired RedisConnectionFactory redisConnectionFactory; @Bean TokenStore tokenStore(){ return new RedisTokenStore(redisConnectionFactory); }} 3.配置授权服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Configuration@EnableAuthorizationServer//开启授权服务器的自动化配置public class AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Autowired TokenStore tokenStore; @Autowired ClientDetailsService clientDetailsService; @Bean AuthorizationCodeServices authorizationCodeServices(){ /* 授权码和令牌有什么区别？授权码是用来获取令牌的，使用一次就失效，令牌则是用来获取资源的 */ return new InMemoryAuthorizationCodeServices();//将授权码存储到内存中 } @Bean AuthorizationServerTokenServices tokenServices() { DefaultTokenServices services = new DefaultTokenServices(); services.setClientDetailsService(clientDetailsService); services.setSupportRefreshToken(true);//是否支持刷新 services.setTokenStore(tokenStore);//指定token的存储方式 services.setAccessTokenValiditySeconds(60 * 60 * 2);//access_token的有效期 services.setRefreshTokenValiditySeconds(60 * 60 * 24 * 3);//refresh_token的有效期 return services; } @Override//配置token的安全约束 public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.checkTokenAccess(\"permitAll()\")//设置token的校验端点为可以直接访问 .allowFormAuthenticationForClients();//支持client_id以及client_secret作登录认证 } @Override//配置客户端的信息用于校验发来请求的客户端 public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory()//为了简单示范直接将客户端信息存储在内存里 .withClient(\"atomsk\")//客户端id .secret(new BCryptPasswordEncoder().encode(\"321\")) .resourceIds(\"res1\") .authorizedGrantTypes(\"authorization_code\",\"refresh_token\") .scopes(\"all\") .redirectUris(\"http://localhost:8082/index.html\"); } @Override//配置token的访问端点和token服务 public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authorizationCodeServices(authorizationCodeServices()) .tokenServices(tokenServices()); }} 资源服务器tip：小项目授权服务器和资源服务器可以放在一起。 和创建授权服务器一样，创建SpringBoot应用并加入三个依赖： web spring cloud security spirng cloud OAuth2 1.加入如下配置： 12345678910111213141516171819202122232425@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Bean//如果资源服务器和授权服务器是放在一起的，就不需要配置 RemoteTokenServices RemoteTokenServices tokenServices(){ RemoteTokenServices services=new RemoteTokenServices(); services.setCheckTokenEndpointUrl(\"http://localhost:8080/oauth/check_token\");//校验地址 services.setClientId(\"atomsk\"); services.setClientSecret(\"321\"); return services; } @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(\"res1\").tokenServices(tokenServices()); } @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasAnyRole(\"admin\") .anyRequest().authenticated(); }} 2.添加两个配置接口 1234567891011@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello\"; } @GetMapping(\"/admin/hello\") public String admin() { return \"admin\"; }} 第三方应用第三方应用就是一个普通的 Spring Boot 工程，创建时加入 Thymeleaf 依赖和 Web 依赖即可 1.在templates创建一个index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Tittle&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello,Oauth2 &lt;a href=\"http://localhost:8080/oauth/authorize?client_id=atomsk&amp;response_type=code\"&gt;第三方登录&lt;/a&gt;&lt;!-- &amp;scope=all&amp;redirect_uri=http://localhost:8082/index.html 在这不加也没影响--&gt;&lt;h1 th:text=\"${msg}\"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 超链接里的参数： client_id 客户端 ID，根据我们在授权服务器中的实际配置填写。 response_type 表示响应类型，这里是 code 表示响应一个授权码。 2.定一个Controller 1234567891011121314151617181920212223242526@Controllerpublic class HelloController { @Autowired RestTemplate restTemplate; @GetMapping(\"/index.html\") public String hello(String code, Model model) { if (code != null) { MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;(); map.add(\"code\", code); map.add(\"client_id\", \"atomsk\"); map.add(\"client_secret\", \"321\"); map.add(\"redirect_uri\", \"http://localhost:8082/index.html\"); map.add(\"grant_type\", \"authorization_code\"); Map&lt;String,String&gt; resp = restTemplate.postForObject(\"http://localhost:8080/oauth/token\", map, Map.class); String access_token = resp.get(\"access_token\"); System.out.println(access_token); HttpHeaders headers = new HttpHeaders(); headers.add(\"Authorization\", \"Bearer \" + access_token); HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(headers); ResponseEntity&lt;String&gt; entity = restTemplate.exchange(\"http://localhost:8081/admin/hello\", HttpMethod.GET, httpEntity, String.class); model.addAttribute(\"msg\", entity.getBody()); } return \"index\"; }} 如果 code 不为 null，也就是如果是通过授权服务器重定向到这个地址来的，那么我们做如下两个操作： 根据拿到的 code，去请求 http://localhost:8080/oauth/token 地址去获取 Token，返回的数据结构如下： 1234567{ \"access_token\": \"e7f223c4-7543-43c0-b5a6-5011743b5af4\", \"token_type\": \"bearer\", \"refresh_token\": \"aafc167b-a112-456e-bbd8-58cb56d915dd\", \"expires_in\": 7199, \"scope\": \"all\"} 接下来，根据我们拿到的 access_token，去请求资源服务器，注意 access_token 通过请求头传递，最后将资源服务器返回的数据放到 model 中 本博文完全参照江南一点雨的Oauth2的授权码模式案例写成，感兴趣的点击下面链接访问原文： http://www.javaboy.org/2020/0414/oauth2_authorization_code.html","link":"/blog/2020/05/26/SpringSecurity-OAuth2-Demo/"},{"title":"设计模式之创建型模式","text":"创建型模式创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。 创建型模式分为以下几种。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式 单例（Singleton）模式参考博客地址 饿汉式饿汉模式，可以想象一个很饿的人，需要立马吃东西，饿汉模式便是这样，在类加载时就创建对象，由于在类加载时就创建单例，因此不存在线程安全问题 1234567891011121314151617public class Hungry { // 可能会浪费空间 private byte[] data1 = new byte[1024*1024]; private byte[] data2 = new byte[1024*1024]; private byte[] data3 = new byte[1024*1024]; private byte[] data4 = new byte[1024*1024]; private Hungry(){ } private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance(){ return HUNGRY; }} 如果在该类里面存在大量开辟空间的语句，但又不马上使用他们，这时这样的单例模式会消耗大量的内存，影响性能 懒汉式顾名思义，懒汉式，就是懒，即在类加载时并不会立马创建单例对象，而是只生成一个单例的引用，即可以延时加载 123456789101112131415public class LazyMan { private LazyMan() { } private static LazyMan instance; //提供公共的获取方法,因为不是在类加载时就创建对象，因此存在线程安全问题，使用synchronized关键字保证线程安全，效率降低 public static synchronized LazyMan getInstance() { if (instance == null) { instance = new LazyMan(); } return instance; }} 懒汉式使用同步锁锁住了整个方法，效率较低 DCL懒汉式(双重检测锁模式)参考博客地址 双重检测锁模式的关键点： 防止多线程重复创建——双重检测 避免实例化对象时指令重排——volatile关键字 123456789101112131415public class LazyMan { 2. private volatile static LazyMan lazyMan; 1. public static LazyMan getInstance(){ if (lazyMan==null){ synchronized (LazyMan.class){ if (lazyMan==null){ //不是一个原子性操作，所以要给对象加上volatile关键字 lazyMan = new LazyMan(); } } } return lazyMan; }} 由于JVM底层内部模型的原因，偶尔会出现问题，因此不建议使用 静态内部类使用静态内部类解决了线程安全问题，并实现了延时加载 12345678910public class Holder{ private Holder(){} public static Holder getInstance(){ return InnerClass.HOLDER; } public static calss InnerClass{ private static finnal Holder HOLDER=new Holder(); }} 对于以上四种实现单例模式的方式，都可以使用反射进行破坏，因此可以用一个随机标识位防止反射破坏，但不能阻止反编译破解 1234567891011private static boolean atomsk = false;private Singleton(){ synchronized (Singleton.class){ if (atomsk == false){ atomsk = true; }else { throw new RuntimeException(\"不要试图使用反射破坏异常\"); } }} 枚举单例使用枚举可以阻止反射，详见狂神说单例 123456public enum EnumSingle{ INSTANCE; public EnumSingle getInstance(){ return INSTANCE; }} 五种实现单例模式的方式的对比 饿汉式：线程安全（不排除反射），调用效率高，不能延时加载 懒汉式：线程安全（不排除反射）,调用效率不高，可以延时加载 DCL懒汉式：由于JVM底层模型原因，偶尔出现问题，不建议使用 静态内部类式：线程安全（不排除反射），调用效率高，可以延时加载 枚举单例：线程安全，调用效率高，不能延时加载 单例模式常见场景 Windows的任务管理器、回收站等 servlet中每个servlet都是单例 数据库连接池一般都是单例的 Spring中每个Bean都是单例的 原型（Prototype）模式原型模式的定义与特点原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。 原型模式的结构由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。 原型模式包含以下主要角色。 抽象原型类：规定了具体原型对象必须实现的接口。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 其结构图如图 1 所示。 图1 原型模式的结构图 原型模式的扩展原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。其结构图如图 2 所示。 图2 带原型管理器的原型模式的结构图 【例1】用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积。分析：本实例中由于存在不同的图形类，例如，“圆”和“正方形”，它们计算面积的方法不一样，所以需要用一个原型管理器来管理它们，图 3 所示是其结构图。 图3 图形生成器的结构图 建造者（Builder）模式模式的定义与特点建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 该模式的主要优点如下： 各个具体的建造者相互独立，有利于系统的扩展。 客户端不必知道产品内部组成的细节，便于控制细节风险。 其缺点如下： 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，该模式会增加很多的建造者类。 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 模式的结构建造者（Builder）模式的主要角色如下。 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 模式的应用实例【例1】用建造者（Builder）模式描述客厅装修。 分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。 这里客厅是产品，包括墙、电视和沙发等组成部分。具体装修工人是具体建造者，他们负责装修与墙、电视和沙发的布局。项目经理是指挥者，他负责指挥装修工人进行装修。 其类图如图 4 所示。 图4 客厅装修的结构图 模式的应用场景建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。 模式的扩展建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。","link":"/blog/2020/07/10/design-patterns-creating/"},{"title":"设计模式之两种工厂模式","text":"工厂方法（FactoryMethod）模式模式的定义与特点工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。 我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。 工厂方法模式的主要优点有： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 模式的结构工厂方法模式的主要角色如下。 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 模式的应用实例【例1】用工厂方法模式设计畜牧场。 分析：有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛，所以该实例用工厂方法模式比较适合。 对养马场和养牛场等具体工厂类，只要定义一个生成动物的方法 newAnimal() 即可，并定义一个 show() 方法来显示它们。 其结构图如图 1 所示。 图1 畜牧场结构图 模式的应用场景工厂方法模式通常适用于以下场景。 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。 客户不关心创建产品的细节，只关心产品的品牌。 模式的扩展当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式，其结构图如图 2所示。 图2 简单工厂模式的结构图 抽象工厂（AbstractFactory）模式前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。 同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。 本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 13所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。 图3 电器工厂的产品等级与产品族 模式的定义与特点抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 使用抽象工厂模式一般要满足以下条件。 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。 系统一次只可能消费其中某一族产品，即同族的产品一起使用。 抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。 当增加一个新的产品族时不需要修改原代码，满足开闭原则。 其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。 模式的结构抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。 抽象工厂模式的主要角色如下。 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。 模式的应用实例【例1】用抽象工厂模式设计农场类。 分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，所以本实例比前面介绍的畜牧场类复杂，必须用抽象工厂模式来实现。 本例用抽象工厂模式来设计两个农场，一个是韶关农场用于养牛和种菜，一个是上饶农场用于养马和种水果，可以在以上两个农场中定义一个生成动物的方法 newAnimal() 和一个培养植物的方法 newPlant()。 其结构图如图 4 所示。 图4 农场类的结构图 模式的应用场景抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。 抽象工厂模式通常适用于以下场景： 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。 模式的扩展抽象工厂模式的扩展有一定的“开闭原则”倾斜性： 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。 另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。 工厂方法和抽象工厂的区别来源：抽象工厂、工厂方法和简单工厂的不同点及使用心得 抽象工厂模式​ 假设有m家工厂，n种部件，如果按照抽象工厂模式去设计的话，最终将会有1个抽象工厂接口（客户端用来初始化并决定具体用哪家工厂去生产产品），n个抽象部件接口（定义每个部件的规范标准，这些标准在各个工厂下都是一样的），m个具体工厂类（每个工厂有n个方法，用来初始化n个具体部件生产类），m*n个具体部件类（这些类是真正生产产品的类）。 【例2】1个抽象工厂接口，2个部件（手机和路由器)不同厂商对应产品 抽象工厂对于变化的封装： 如果要切换工厂，只需要在最开始初始化工厂类的时候换另一家工厂就好了，而整个结构都无需改动。 如果增加部件，抽象工厂接口以及其子工厂都需要添加能生产此部件的方法，同时还需要添加一个此部件的抽象接口以及每种工厂生产这种部件的具体方法，好处是已有的部件类不需要改动。 如果增加工厂，首先需要增加此工厂并实现抽象工厂类，同时需要在每个抽象部件那里加一个此工厂生产对应部件的具体类，好处是已有工厂类和部件类都不需要改动。 综上所述，抽象工厂模式基本上完美的遵循了开放封闭原则，即使第二种情况需要修改已有的工厂类，但由于工厂类的职责是去初始化并返回一个真正的部件生产类，因此已有的核心类部件类依然没有因为扩展而做过任何修改。 工厂方法模式​ 工厂方法可以说是抽象工厂的一个特例，当工厂里只有一种产品的时候，抽象工厂的结构就简化成工厂方法的结构了。此时会有一个抽象工厂接口，一个抽象产品接口，假设还是有m家工厂，那么会有m个具体工厂类，同时有m个具体产品类，工厂类和产品类是一一对应的关系，每个工厂类负责去初始化其对应的产品类。 ​ 工厂方法也是符合开放封闭原则的，如果再加一个新的工厂，只需要增加一个工厂类和此工厂生产产品的具体类就OK了，其他工厂类和产品类都无需改动。 简单工厂模式​ 简单工厂模式并没有AbstractFactory接口，它是根据参数或者配置文件等事先定义好的变量，然后利用分支判断或者反射技术来动态的初始化具体产品类并返回。它的产品类接口和数量与其他两种工厂模式一样，不同的地方在于它没有那么多的工厂类，可以只用一个静态工厂类来生成想要的产品。 由于增加工厂或者产品都需要修改静态工厂类，因此它不符合开放封闭原则。好处是大大减少了工厂类，若使用了反射技术，也会减少很多判断分支代码量。 使用场景总结​ 如果产品单一，并且客户端在创建产品实例时需要用灵活的参数来指定具体使用哪种工厂，那么可以优先使用简单工厂；若客户端相对稳定的指定一种工厂，同时在多个地方用此工厂创建产品类，则优先考虑用工厂方法模式。如果产品有多种，则考虑使用抽象工厂模式。需要注意的是抽象工厂模式里的工厂类既可以用工厂方法来实现，此时是标准的抽象工厂模式；也可用简单工厂来实现，这种情况一般是用一个静态工厂类和多个静态方法来代替那一大堆的工厂类，工厂种类的指定可以用常量或配置文件，并且在一定的环境下相对稳定。","link":"/blog/2020/07/10/design-patterns-factory/"},{"title":"设计模式——适配器模式和桥接模式","text":"结构型模式结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 结构型模式分为以下 7 种： 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式，下面我们会分别、详细地介绍它们的特点、结构与应用。 适配器（Adapter）模式模式的定义与特点适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 该模式的主要优点如下。 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。 模式的结构与实现类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。 1. 模式的结构适配器模式（Adapter）包含以下主要角色。 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 类适配器模式的结构图如图 1 所示。 图1 类适配器模式的结构图 对象适配器模式的结构图如图 2 所示。 图2 对象适配器模式的结构图 2. 模式的实现(1) 类适配器模式的代码如下。 1234567891011121314151617181920212223242526272829303132package adapter;//目标接口interface Target{ public void request();}//适配者接口class Adaptee{ public void specificRequest() { System.out.println(\"适配者中的业务代码被调用！\"); }}//类适配器类class ClassAdapter extends Adaptee implements Target{ public void request() { specificRequest(); }}//客户端代码public class ClassAdapterTest{ public static void main(String[] args) { System.out.println(\"类适配器模式测试：\"); Target target = new ClassAdapter(); target.request(); }} 程序的运行结果如下： 12类适配器模式测试：适配者中的业务代码被调用！ (2)对象适配器模式的代码如下。 12345678910111213141516171819202122232425package adapter;//对象适配器类class ObjectAdapter implements Target{ private Adaptee adaptee; public ObjectAdapter(Adaptee adaptee) { this.adaptee=adaptee; } public void request() { adaptee.specificRequest(); }}//客户端代码public class ObjectAdapterTest{ public static void main(String[] args) { System.out.println(\"对象适配器模式测试：\"); Adaptee adaptee = new Adaptee(); Target target = new ObjectAdapter(adaptee); target.request(); }} 说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。 程序的运行结果如下： 12对象适配器模式测试：适配者中的业务代码被调用！ 模式的应用场景适配器模式（Adapter）通常适用于以下场景。 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 模式的扩展适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图 3 所示。 图3 双向适配器模式的结构图 桥接（Bridge）模式桥接模式的定义与特点桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 桥接（Bridge）模式的优点是： 由于抽象与实现分离，所以扩展能力强； 其实现细节对客户透明。 缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 桥接模式的结构可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。 桥接（Bridge）模式包含以下主要角色。 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。 桥接模式的应用实例【例1】用桥接（Bridge）模式模拟女士皮包的选购。 分析：女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适。 本实例按用途分可选钱包（Wallet）和挎包（HandBag），按颜色分可选黄色（Yellow）和红色（Red）。可以按两个维度定义为颜色类和包类。 颜色类（Color）是一个维度，定义为实现化角色，它有两个具体实现化角色：黄色和红色，通过 getColor() 方法可以选择颜色；包类（Bag）是另一个维度，定义为抽象化角色，它有两个扩展抽象化角色：挎包和钱包，它包含了颜色类对象，通过 getName() 方法可以选择相关颜色的挎包和钱包。 该例子结构图如图 3 所示。 图3 女士皮包选购的结构图 程序代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//实现化角色：颜色interface Color{ String getColor();}//具体实现化角色：黄色class Yellow implements Color{ public String getColor() { return \"yellow\"; }}//具体实现化角色：红色class Red implements Color{ public String getColor() { return \"red\"; }}//抽象化角色：包abstract class Bag{ protected Color color; public void setColor(Color color) { this.color=color; } public abstract String getName();}//扩展抽象化角色：挎包class HandBag extends Bag{ public String getName() { return color.getColor()+\"HandBag\"; } }//扩展抽象化角色：钱包class Wallet extends Bag{ public String getName() { return color.getColor()+\"Wallet\"; } } 桥接模式的应用场景桥接模式通常适用于以下场景。 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。 桥接模式模式的扩展在软件开发中，有时桥接（Bridge）模式可与适配器模式联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如图 4 所示。 图4 桥接模式与适配器模式联用的结构图","link":"/blog/2020/07/09/design-patterns-structure/"},{"title":"设计模式概述","text":"笔记整理自C语言中文网 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。 设计模式分类设计模式有两种分类方法，即根据模式的目的和作用的范围来分。 范围\\目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法 (类）适配器 模板方法、解释器 对象模式 单例 原型 抽象工厂 建造者 代理 (对象）适配器 桥接 装饰 外观 享元 组合 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录 根据目的来分根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 根据作用范围来分根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 OOP七大设计原则开闭原则开闭原则（Open Closed Principle，OCP）的含义是：当应用的需求改变时，在不修改软件实体的源代码的前提下，可以扩展模块的功能，使其满足新的需求。 核心思想：对扩展开发，对修改关闭 开闭原则的作用 对软件测试的影响 软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。 可以提高代码的可复用性 粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。 可以提高软件的可维护性 遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。 开闭原则的实现方法可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。 里氏替换原则里氏替换原则（Liskov Substitution Principle，LSP）主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。 核心思想：子类可以扩展父类的功能，但不能改变父类原有的功能，也要尽量避免重写父类的方法 里氏替换原则的作用里氏替换原则的主要作用如下。 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。 里氏替换原则的实现方法里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。 【例1】里氏替换原则在“几维鸟不是鸟”实例中的应用。 分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 1 所示。 图1 “几维鸟不是鸟”实例的类图 如果按照该类图设计程序，将会出现运行错误，原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。其类图如图 2 所示。 图2 “几维鸟是动物”实例的类图 --- 依赖倒置原则依赖倒置原则（Dependence Inversion Principle，DIP）的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象 核心思想：要面向接口编程，不要面向实现编程 依赖、倒置原则的作用 依赖倒置原则可以降低类间的耦合性。 依赖倒置原则可以提高系统的稳定性。 依赖倒置原则可以减少并行开发引起的风险。 依赖倒置原则可以提高代码的可读性和可维护性。 依赖倒置原则的实现方法依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。 每个类尽量提供接口或抽象类，或者两者都具备。 变量的声明类型尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 使用继承时尽量遵循里氏替换原则。 【例1】不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码，其类图如图 1 所示。 图1 顾客购物程序的类图 --- 单一职责原则单一职责原则（Single Responsibility Principle，SRP），该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 核心思想：控制类的粒度大小、将对象解耦、提高其内聚性。 单一职责原则的优点 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。 提高类的可读性。复杂性降低，自然其可读性会提高。 提高系统的可维护性。可读性提高，那自然更容易维护了。 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。 单一职责原则的实现方法单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。 【例1】大学学生工作管理程序。 分析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做 法是生活辅导由辅导员负责，学业指导由学业导师负责，其类图如图 1 所示。 图1 大学学生工作管理程序的类图 注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。 接口隔离原则接口隔离原则（Interface Segregation Principle，ISP）的定义是：客户端不应该被迫依赖于它不使用的方法，该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上 核心思想：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 接口隔离原则的优点接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。 接口隔离原则的实现方法在具体应用接口隔离原则时，应该根据以下几个规则来衡量。 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 【例1】学生成绩管理程序。 分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中，其类图如图 1 所示。 图1 学生成绩管理程序的类图 --- 迪米特法则迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，其定义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 核心思想：要与你的直接朋友交谈，不跟“陌生人”说话 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。 迪米特法则的优点迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。 但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 迪米特法则的实现方法从迪米特法则的定义和特点可知，它强调以下两点： 从依赖者的角度来说，只依赖应该依赖的对象。 从被依赖者的角度说，只暴露应该暴露的方法。 所以，在运用迪米特法则时要注意以下 6 点。 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。 在类的结构设计上，尽量降低类成员的访问权限。 在类的设计上，优先考虑将一个类设置成不变类。 在对其他类的引用上，将引用其他对象的次数降到最低。 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。 谨慎使用序列化（Serializable）功能。 【例1】明星与经纪人的关系实例。 分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如图 1 所示。 图1 明星与经纪人的关系图 --- 合成复用原则合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP） 核心思想：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 合成复用原则的重要性通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 合成复用原则的实现方法合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。 【例1】汽车分类管理程序。 分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 1 所示是用继淨：关系实现的汽车分类的类图。 图1 用继承关系实现的汽车分类的类图 从图 1 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。 图2 用组合关系实现的汽车分类的类图 --- 小结以上 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。","link":"/blog/2020/07/09/design-patterns-summery/"},{"title":"Vue基础","text":"Vue.js是什么?是一位华裔工程师（尤雨溪）开发的前端js库 特点： 遵循MVVM模式 编码简洁, 体积小, 运行效率高, 移动/PC端开发 它本身只关注UI, 可以轻松引入vue插件和其它第三库开发项目 vue常用的组件库： vue-cli: vue脚手架 vue-resource(axios): ajax请求 vue-router: 路由 vuex: 状态管理 vue-lazyload: 图片懒加载 vue-scroller: 页面滑动相关 mint-ui: 基于vue的组件库(移动端) element-ui: 基于vue的组件库(PC端) 基本使用123456789101112131415161718192021&lt;div id=\"test\"&gt; &lt;input type=\"text\" v-model=\"msg\"&gt;&lt;br&gt; &lt;p&gt;hello {{msg}}&lt;/p&gt;&lt;br&gt; &lt;a v-bind:href=\"url\"&gt;访问指定站点&lt;/a&gt;&lt;br&gt; &lt;button v-on:click=\"test(\"atomsk\")\"&gt;v-on测试&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el: '#test', data: { msg: 'vue', url: 'https://atomskgit.github.io/blog' }, methods: { test (name) { alert(name + '你好啊!!!') } } })&lt;/script&gt; vm里的属性： el：指定dom标签容器的选择器，vue就会管理对应标签及其字标签 data：初始化数据 双大括号表达式 v-xxx指令： 双向数据绑定：v-model=”msg” 强制数据绑定：v-bind:href=”url”，可简写成 :href=”url” 绑定事件监听：v-on:click=”test”，可简写成 @click=”test” 计算属性和监视属性计算属性 在computed属性对象中定义计算属性的方法，在页面中用 显示结果利用getter/setter方法实现对属性数据的显示和监视 有缓存，多次读取只执行一次getter 监视属性 通过通过 vm 对象的$watch()或 watch 属性对象配置来监视指定的属性 当属性变化时, 回调函数自动调用, 在函数内部进行计算 computed和watch对比： 12345678910111213141516171819202122232425262728293031 姓: &lt;input type=\"text\" placeholder=\"First Name\" v-model=\"firstName\"&gt;&lt;br&gt; 名: &lt;input type=\"text\" placeholder=\"Last Name\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名1: &lt;input type=\"text\" placeholder=\"Full Name1\" v-model=\"fullName1\"&gt;&lt;br&gt; 姓名2: &lt;input type=\"text\" placeholder=\"Full Name2\" v-model=\"fullName2\"&gt;&lt;br&gt;&lt;script&gt;computed: { fullName1: { // 当获取当前属性值时自动调用, 将返回值作为属性值 get () { return this.firstName + '-' + this.lastName }, // 当属性值发生了改变时自动调用 set (value) {//value即当前监视属性的值 const names = value.split('-') this.firstName = names[0] this.lastName = names[1] } }//watch的第一种形式watch: { // 配置监视firstName firstName: function (value) { this.fullName2 = value + '-' + this.lastName } }//watch的第二种形式vm.$watch('lastName', function (value) { this.fullName2 = this.firstName + '-' + value })&lt;/script&gt; 绑定class和style1234567&lt;!--class的三种形式 --&gt;&lt;p :class=\"myclass\"&gt;表达式是字符串&lt;/p&gt;&lt;p :class=\"{classA: hasClassA, classB: hasClassB}\"&gt;表达式是对象&lt;/p&gt;&lt;p :class=\"['classA', 'classC']\"&gt; 表达式是数组&lt;/p&gt;&lt;!--style --&gt;&lt;p :style=\"{color:activeColor, fontSize: fontSize}\"&gt;&lt;/p&gt;&lt;button @click=\"update\"&gt;更新&lt;/button&gt; 改变对应的变量即可： 1234567891011&lt;script&gt; methods: { update () { this.myClass = 'classB' this.hasClassA = true this.hasClassB = !hasClassB this.activeColor = 'red' this.fontSize = '30px' } }&lt;/script&gt; 生命周期详见：https://www.jianshu.com/p/4d3e554269c1 一些干货使用 v-for遍历对象，第一个参数是值，第二个参数是键 12345&lt;ul&gt; &lt;li v-for=\"(p, index) in persons\" :key=\"index\"&gt; {{index}}--{{p.name}}--{{p.age}} &lt;/li&gt;&lt;/ul&gt; 事件修饰符： @click.prevent=”xxx”：阻止事件的默认行为，即 event.preventDefault() @click.stop =”xxx”：停止事件冒泡，即 event.stopPropagation() 按键修饰符：@keydown.按键码/常用按键名=”xxx”。使用：给密码输入框或者验证码输入框加上sumbit方法 过滤器：对要显示的数据进行特定格式化后再显示 12345678定义:Vue.filter(filterName, function(value[,arg1,arg2,...]){ // 进行一定的数据处理 return newValue})使用：&lt;div&gt;{{myData | filterName}}&lt;/div&gt;&lt;div&gt;{{myData | filterName(arg)}}&lt;/div&gt; 其他指令： ref : 为某个元素注册一个唯一标识, vue对象通过$refs属性访问这个元素对象 v-cloak : 主要用于隐藏未被vue解析到的元素, 在style里加上: [v-cloak] { display: none }","link":"/blog/2020/05/30/Vue-base/"},{"title":"HTTP概述","text":"基于HTTP的组件系统HTTP是一个client-server协议：请求通过一个实体被发出，实体也就是用户代理。大多数情况下，这个用户代理都是指浏览器，当然它也可能是任何东西，比如一个爬取网页生成维护搜索引擎索引的机器爬虫。 每一个发送到服务器的请求，都会被服务器处理并返回一个消息，也就是response。在这个请求与响应之间，还有许许多多的被称为proxies的实体，他们的作用与表现各不相同，比如有些是网关，还有些是caches等。 实际上，在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机。由于Web的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP位于最上层的应用层。虽然底层对于分析网络问题非常重要，但是大多都跟对HTTP的描述不相干。 客户端user-agent 就是任何能够为用户发起行为的工具。这个角色通常都是由浏览器来扮演。一些例外情况，比如是工程师使用的程序，以及Web开发人员调试应用程序。 浏览器总是作为发起一个请求的实体，他永远不是服务器（虽然近几年已经出现一些机制能够模拟由服务器发起的请求消息了）。 要展现一个网页，浏览器首先发送一个请求来获取页面的HTML文档，再解析文档中的资源信息发送其他请求，获取可执行脚本或CSS样式来进行页面布局渲染，以及一些其它页面资源（如图片和视频等）。然后，浏览器将这些资源整合到一起，展现出一个完整的文档，也就是网页。浏览器执行的脚本可以在之后的阶段获取更多资源，并相应地更新网页。 一个网页就是一个超文本文档。也就是说，有一部分显示的文本可能是链接，启动它（通常是鼠标的点击）就可以获取一个新的网页，使得用户可以控制客户端进行网上冲浪。浏览器来负责发送HTTP请求，并进一步解析HTTP返回的消息，以向用户提供明确的响应。 Web服务端在上述通信过程的另一端，是由Web Server来服务并提供客户端所请求的文档。Server只是虚拟意义上代表一个机器：它可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 …）发起请求来获取部分或全部资源。 Server 不一定是一台机器，但一个机器上可以装载的众多Servers。在HTTP/1.1 和Host头部中，它们甚至可以共享同一个IP地址。 代理（Proxies）在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是透明的，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为代理（Proxies）。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）。代理主要有如下几种作用： 缓存（可以是公开的也可以是私有的，像浏览器的缓存） 过滤（像反病毒扫描，家长控制…） 负载均衡（让多个服务器服务不同的请求） 认证（对不同资源进行权限管理） 日志记录（允许存储历史信息） HTTP的基本性质HTTP 是简单的虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。 HTTP 是可扩展的在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。 HTTP 是无状态，有会话的 HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。 注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。 HTTP 和连接一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。 在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接，打开一个 TCP 连接需要多次往返交换消息（因此耗时）。HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 链接更低效。 为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。 为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议QUIC。 HTTP能控制什么多年以来，HTTP良好的扩展性使得越来越多的Web功能归其控制。缓存和认证很早就可以由HTTP来控制了。另一方面，对同源同域的限制到2010年才有所改变。 以下是可以被HTTP控制的常见特性。 缓存 文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。 开放同源限制为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。 认证一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用Authenticate相似的头部即可，或用HTTP Cookies来设置指定的会话。 代理和隧道通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。 会话使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。 HTTP流当客户端想要和服务端进行信息交互时（服务端是指最终服务器，或者是一个中间代理），过程表现为下面几步： 打开一个TCP连接：TCP连接被用来发送一条或多条请求，以及接受响应消息。客户端可能打开一条新的连接，或重用一个已经存在的连接，或者也可能开几个新的TCP连接连向服务端。 发送一个HTTP报文：HTTP报文（在HTTP/2之前）是语义可读的。在HTTP/2中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。 123GET / HTTP/1.1Host: developer.mozilla.orgAccept-Language: fr 读取服务端返回的报文信息： 12345678910HTTP/1.1 200 OKDate: Sat, 09 Oct 2010 14:28:02 GMTServer: ApacheLast-Modified: Tue, 01 Dec 2009 20:18:22 GMTETag: \"51142bc1-7449-479b075b2891b\"Accept-Ranges: bytesContent-Length: 29769Content-Type: text/html&lt;!DOCTYPE html... (here comes the 29769 bytes of the requested web page) 关闭连接或者为后续请求重用连接。 当HTTP流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而HTTP流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，HTTP流水线已被在有多请求下表现得更稳健的HTTP/2的帧所取代。 HTTP报文HTTP/1.1以及更早的HTTP协议报文都是语义可读的。在HTTP/2中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文头部的压缩和复用。即使只有原始HTTP报文的一部分以HTTP/2发送出来，每条报文的语义依旧不变，客户端会重组原始HTTP/1.1请求。因此用HTTP/1.1格式来理解HTTP/2报文仍旧有效。 有两种HTTP报文的类型，请求与响应，每种都有其特定的格式。 请求HTTP请求的一个例子： 请求由以下元素组成： 一个HTTP的method，经常是由一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送HTML form表单值（POST方法），虽然在一些情况下也会有其他操作。 要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有protocol （http://），domain（developer.mozilla.org），或是TCP的port（HTTP一般在80端口）。 HTTP协议版本号。 为服务端表达其他信息的可选头部headers。 对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似。 响应HTTP响应的一个例子： 响应报文包含了下面的元素： HTTP协议版本号。 一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。 一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。 HTTP headers，与请求头部类似。 可选项，比起请求报文，响应报文中更常见地包含获取的资源body。 基于HTTP的APIs基于HTTP的最常用API是XMLHttpRequest API，可用于在user agent和服务器之间交换数据。 现代Fetch API提供相同的功能，具有更强大和灵活的功能集。 另一种API，即服务器发送的事件，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件。 使用EventSource接口，客户端打开连接并建立事件句柄。 客户端浏览器自动将到达HTTP流的消息转换为适当的Event对象，并将它们传递给专门处理这类type事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给onmessage事件处理程序处理。","link":"/blog/2020/05/28/HTTP-Intro/"},{"title":"设计模式之代理模式","text":"代理模式的定义与特点代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 代理模式的主要优点有： 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 其主要缺点是： 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 增加了系统的复杂度； 代理模式的结构与实代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。 代理模式的主要角色如下。 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 其结构图如图 1 所示。 图1 代理模式的结构图 静态代理静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 应用实例：租房 123456789101112131415161718192021222324252627282930313233343536373839404142434445//抽象角色：租房public interface Rent { public void rent();}//真实角色: 房东，房东要出租房子public class Host implements Rent{ public void rent() { System.out.println(\"房屋出租\"); }}//代理角色：中介public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房 public void rent(){ seeHouse(); host.rent(); fare(); } public void seeHouse(){ System.out.println(\"带房客看房\"); } public void fare(){ System.out.println(\"收中介费\"); }}//客户public class Client { public static void main(String[] args) { //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); }} 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。 静态代理的好处 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 公共的业务由代理来完成 . 实现了业务的分工 公共业务发生扩展时变得更加集中和方便 缺点 :类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! 动态代理 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理—-JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 JDK的动态代理InvocationHandler是代理实例的调用处理程序需要实现的接口，只有一个方法 1Object invoke(Object proxy, Method method, Object[] args)； 参数： proxy - 调用该方法的代理实例 method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口 args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 Proxy该类即为动态代理类，提供了创建动态代理类和实例的静态方法： static Class getProxyClass (ClassLoaderloader, Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。 static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法) 所谓DynamicProxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些 interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。 通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。 代码实现 抽象角色和真实角色和之前的一样 ProxyInvocationHandler. java 即代理角色 12345678910111213141516171819202122232425262728293031323334public class ProxyInvocationHandler implements InvocationHandler { private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; } //看房 public void seeHouse(){ System.out.println(\"带房客看房\"); } //收中介费 public void fare(){ System.out.println(\"收中介费\"); }} Client . java 1234567891011121314//租客public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); }} 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、 动态代理的好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！","link":"/blog/2020/07/11/design-patterns-proxy/"}],"tags":[{"name":"数据库","slug":"数据库","link":"/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Docker","slug":"Docker","link":"/blog/tags/Docker/"},{"name":"MySQL","slug":"MySQL","link":"/blog/tags/MySQL/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/blog/tags/SpringBoot/"},{"name":"Swagger2","slug":"Swagger2","link":"/blog/tags/Swagger2/"},{"name":"Spring Security","slug":"Spring-Security","link":"/blog/tags/Spring-Security/"},{"name":"Oauth2","slug":"Oauth2","link":"/blog/tags/Oauth2/"},{"name":"设计模式","slug":"设计模式","link":"/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"AOP","slug":"AOP","link":"/blog/tags/AOP/"},{"name":"前端","slug":"前端","link":"/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","link":"/blog/tags/Vue/"},{"name":"HTTP","slug":"HTTP","link":"/blog/tags/HTTP/"}],"categories":[{"name":"配置","slug":"配置","link":"/blog/categories/%E9%85%8D%E7%BD%AE/"},{"name":"运维","slug":"运维","link":"/blog/categories/%E8%BF%90%E7%BB%B4/"},{"name":"数据库","slug":"数据库","link":"/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/blog/categories/SpringBoot/"},{"name":"安全","slug":"安全","link":"/blog/categories/%E5%AE%89%E5%85%A8/"},{"name":"MySQL","slug":"数据库/MySQL","link":"/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"设计模式","slug":"设计模式","link":"/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","link":"/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"前端","slug":"前端","link":"/blog/categories/%E5%89%8D%E7%AB%AF/"},{"name":"创建型模式","slug":"设计模式/创建型模式","link":"/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"框架","slug":"前端/框架","link":"/blog/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"}]}